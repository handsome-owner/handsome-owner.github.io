<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[客户端负载均衡-Spring-Cloud-Ribbon]]></title>
    <url>%2F2019%2F10%2F23%2F%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-Spring-Cloud-Ribbon%2F</url>
    <content type="text"><![CDATA[客户端负载均衡 Spring Cloud RibbonSpringCloudRibbon是一个基于HTTP和TCP的客户端负载均衡工具，他基于Netflix Ribbon实现。通过 SpringCloud的封装，可以让我们轻松将面向服务的REST请求自动转换成客户端负载均衡的服务调用。Spring Cloud Ribbon是一个工具框架，他不像注册中心、配置中心、API网关那样需要单独部署，但是他几乎存在于每一个Spring Cloud构建的微服务和基础设施中，因为微服务的调用，API网关的请求转发等内容都是通过Ribbon来实现的，包括后面的Feign也是基于Ribbon实现的工具。 客户端负载均衡：负载均衡在系统架构中是一个非常重要且不得不去实施的内容。负载均衡对系统高可用，网络压力的缓解，处理能力扩容的重要手段之一。其中分为硬件的负载均衡和软件的负载均衡。硬件的负载均衡主要是通过在服务器节点之间安装专门用于负载均衡的设备，如F5等；而软件的负载均衡则是通过在服务器上安装一些具有负载均衡功能或者模块的软件来完成请求分发的功能，比如：Nginx等。不论是硬件的负载均衡还是软件的负载均衡，服务端的负载均衡都是类似下面的构建方式： 负责负载均衡的设备都会维护一个可用的服务端清单，通过心跳检测来剔除故障的服务端节点，来 保证清单中的服务端节点都是可用的。当客户端发送请求到负载均衡设备时，按照某种算法：线性轮询、按权重负载、按流量负载 从维护的服务清单中取出一台服务器的地址，然后进行转发。 而客户端负载均衡和服务端负载均衡最大的不同点在于维护的服务清单所处的位置。在客户端负载均衡中，所有的客户端都维护着做自己要访问的服务端清单，而这些服务端的清单来自于服务注册中心。同服务端负载均衡的架构类似，在客户端负载均衡也需要心跳去维护服务清单的健康性，只是这个步骤需要与服务注册中心相配合。 通过SpringCloudRibbon的封装，我们在微服务架构中使用客户端负载均衡非常简单，只需要两步： 服务提供者只需要启动多个服务实例并注册到服务注册中心或者集群 添加依赖 netflix-ribbon 服务消费者通过被@LoadBalanced修饰的RestTemplate来实现面向服务的接口调用。 RestTemplate详解：GET请求：对于get请求，可以通过两个方法调用实现， 第一种 getForEntity函数。该方法返回的是ResponseEntity，该对象是Spring对HTTP请求的封装，其中包含几个重要元素，HTTP请求状态的枚举对象 HttpStatus ，在他的父类HttpEntity中 还存储着 HTTP请求头的信息对象HttpHeaders以及泛型类型的请求体对象。 12]]></content>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CKEditor富文本编辑器的使用]]></title>
    <url>%2F2019%2F10%2F16%2FCKEditor%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[SpringBoot 集成 CKEditor4 完整实例：快速开始：首先我们需要新建一个SpringBoot的项目，将CKEditor4集成进来。 下载CKEditor 标准版即可 将其解压放在SpringBoot项目的static目录下： 引入官方提供的例子: （修改正确的js地址） edit.html: 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;A Simple Page with CKEditor&lt;/title&gt; &lt;!-- Make sure the path to CKEditor is correct. --&gt; &lt;script src="ckeditor/ckeditor.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form&gt; &lt;textarea name="editor1" id="editor1" rows="10" cols="80"&gt; This is my textarea to be replaced with CKEditor. &lt;/textarea&gt; &lt;script&gt; // Replace the &lt;textarea id="editor1"&gt; with a CKEditor // instance, using default configuration. CKEDITOR.replace( 'editor1' ); &lt;/script&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 此时目录结构如下： 随后启动项目，可以在浏览器中看到效果： 上传图片：此时的CKEditor是无法将我们本地的图片放上去的，需要我们做一些配置： 在解压后的ckeditor中修改config.js 文件： 123config.uploadUrl = '/images/ckeditorUpload?command=QuickUpload&amp;type=Files&amp;responseType=json';config.filebrowserUploadUrl = '/images/ckeditorUpload?command=QuickUpload&amp;type=Files';config.filebrowserImageUploadUrl = '/images/ckeditorUpload?command=QuickUpload&amp;type=Images'; 后面配置的url 需要我们在controller 中自己处理图片上传的处理： 补充：&ensp;&ensp;&ensp;&ensp;由于我们一般都是将SpringBoot项目打成jar包的，所以需要将文件放在本地服务器的其他地方，需要对此做一些修改，applicaion.yml 12345678spring: servlet: multipart: enabled: true max-file-size: 30MB max-request-size: 30MB resources: static-locations: /META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/,file:E:/test 上面的配置是由于上传时请求信息太长，需要对此设置一下，否则在上传图片时会报错。 The field upload exceeds its maximum permitted size of 1048576 bytes. 下面的resources 配置就是本地静态资源文件的映射了，需要全部写上，否则会被覆盖。这样我们在 E:/test 下的文件可以直接像静态资源那样获取到了。 eg: 该目录下的1.jpg 可以通过http://localhost:8080/1.jpg 获取到 上传文件Controller处理：在此处我们选择使用FileUils 来处理文件上传，添加依赖： 123456&lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt; CKEditor 需要我们上传成功之后返回json数据，将其封装成为一个对象： 12345678910111213/** * Created by wangchen on 2019/10/16 15:18 * Description: 上传图片返回信息 CKEditor需要返回json信息 * uploaded 在上传成功时可以设置为1 失败为 0 * fileName 为文件名 * url 为文件的实际访问路径 */@Datapublic class ImageUploadVo &#123; private int uploaded; private String fileName; private String url;&#125; 123456789101112131415161718192021222324252627282930313233@RestController@RequestMapping("/images")@Slf4jpublic class ImageUploadController &#123; private final String imageFilePath = "E:/test/"; /** * 上传图片 * * @param file * @return */ @ResponseBody @RequestMapping("/ckeditorUpload") public ImageUploadVo ckeditorUpload(@RequestParam("upload") MultipartFile file) throws Exception &#123; log.info("开始上传图片"); // 获取文件名 String fileName = file.getOriginalFilename(); // 获取文件的后缀名 String suffixName = fileName.substring(fileName.lastIndexOf(".")); String newFileName = UUID.randomUUID().toString() + suffixName; log.info("上传文件文件名称：&#123;&#125;",newFileName); log.info("上传文件大小 ：&#123;&#125;" + file.getSize()); FileUtils.copyInputStreamToFile(file.getInputStream(), new File(imageFilePath + newFileName)); ImageUploadVo imageUploadVo = new ImageUploadVo(); imageUploadVo.setUploaded(1); imageUploadVo.setFileName(newFileName); imageUploadVo.setUrl("http://localhost:8080/" + newFileName); return imageUploadVo; &#125;&#125; 编辑edit.html 添加点击按钮 查看效果： 123456789&lt;div align="center"&gt; &lt;input type="button" onclick="buttonSubmit()" style="width: 60px;height: 35px;" value="提交表单"/&gt;&lt;/div&gt;&lt;script&gt; function buttonSubmit() &#123; var a = CKEDITOR.instances.editor1.getData(); console.log(a); &#125;&lt;/script&gt; 重新启动项目，直接复制一张图片，可以看到图片可以上传成功,回显也没有问题。 增强图像插件：在上面中，我们已经实现了图片的上传以及回显，但是上传的图片无法拖动来改变位置。 CKEditor 4.3中引入 的可选增强图像插件支持将图像插入编辑器内容。与CKEditor发行版中默认提供的经典Image插件相比，它提供以下功能： 它允许添加图像标题（当其位置更改时不会与图像分开）。 它具有小部件的所有优点，即您可以将图像及其标题视为一个实体，然后在整个编辑器内容区域中选择，删除或移动它。 它支持拖放以更改图像位置。 它使用内联样式或CSS类提供图像对齐，包括居中。 它包括轻松的“单击和拖动”调整大小。 它可以与您选择的文件管理器（例如CKFinder）集成，以支持图像上传和存储。 下面就试试这个插件： 首先需要下载增强型图像插件：增强型插件 解压之后，放到static/ckeditor/plugins下面 编辑 config.js 添加配置： 1config.extraPlugins = 'image2,uploadimage'; 重新启动项目，查看效果： 可以看到 是 现在我们可以简单的调整大小，并为图像添加标题 。 源码地址：https://github.com/handsome-owner/ckeditor-test-all.git 参考资料：CKEditor官方文档 CKEditor实例]]></content>
      <tags>
        <tag>CKEditor 实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务治理-Spring Cloud Eureka]]></title>
    <url>%2F2019%2F10%2F11%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86-Spring-Cloud-Eureka%2F</url>
    <content type="text"><![CDATA[服务治理 Spring Cloud Eureka服务发现简介：&ensp;&ensp;&ensp;&ensp;在传统的应用程序中，我们在调用其他的服务的时候，一般将请求地址硬编码在代码中或者放在配置文件中。但是这种方式是存在缺陷的： 适用场景有局限，如果服务提供者的ip 端口发生了变化，将会影响服务消费者 无法动态伸缩，在生产环境中，每个微服务一般都会部署多个实例，从而实现容灾和负载均衡，硬编码无法适应这种情况。 那么该如何解决这种问题呢？ &ensp;&ensp;&ensp;&ensp;要想解决这种问题，服务消费者需要一个强大的服务发现机制，服务消费者通过这种机制来获取服务提供者的网络信息，即使服务发现者的信息发生变化，消费者也无需修改配置文件。 服务提供者、服务消费者、服务发现者这三者的关系大致如下： 各个微服务在启动时，将自己的网络地址等信息注册到服务发现组件中，服务发现组件会存储这些信息。 服务消费者可以从服务发现组件查询服务提供者的网络地址，并使用该地址的调用服务提供者的接口。 各个微服务与服务发现组件使用一定机制（例如：心跳）通信，服务发现组件长时间没有和微服务通信，就会 注销该实例。 Eureka 简介：&ensp;&ensp;&ensp;&ensp;Eureka是Netflix开源的服务发现组件，本身是一个基于REST的服务。它包含Server和Client两部分。并且服务端和客户端都采用java编写，适用于java实现的分布式系统，或者是JVM语言构建的系统。 &ensp;&ensp;&ensp;&ensp;Spring Cloud Eureka 是Spring Cloud Netflix 微服务套件中的一部分，基于Netflix做了二次封装，主要负责完成微服务架构中的服务治理功能。Spring Cloud 通过为Euraka 增加了Spring Boot风格的自动化配置，我们只需要简单的引入依赖和注解就可以将应用与Eureka整合。 &ensp;&ensp;&ensp;&ensp;Eureka服务端，我们也称为服务注册中心，同其他注册中心一样，支持高可用配置，依托于强一致性提供 良好的实例可用性，可以应对多种不同的故障场景。如果Eureka以集群模式部署，当集群中有分片出现故障时，那么Eureka就转入了自我保护模式。它允许在分片故障期间继续提供服务的发现和注册，当分片恢复运行时，集群中的其他分片会把他们的状态再次同步回来， &ensp;&ensp;&ensp;&ensp; Eureka客户端，主要处理服务的注册与发现。客户端服务通过注解和参数配置的方式，嵌入在客户端应用程序的代码中，在应用程序运行时，Eureka客户端向注册中心注册自身提供的服务，并周期性的发送心跳来更新他的服务租约，同时，他也能从服务端查询当前注册的服务信息，并把他们缓存在本地并周期性的刷新服务状态。 ApplicationService 相当于服务提供者 ApplicationClient 相当于服务消费者 Make Remote Call 相当于调用RESTful API Eureka Server 为Eureka服务端 Eureka Server 提供服务发现的功能，各个微服务启动时，会向Eureka Server注册自己的信息（例如：IP 端口 服务名称等）Eureka Server会存储这些信息。 Eureka Client 是一个java客户端，用于简化与Eureka Server 的交互。 微服务启动后，会周期性的（默认30秒）的向Eureka Server 发送心跳以续约自己的租期 如果Eureka Server 在一段时间内没有接收到某个微服务实例的心跳，Eureka Server 会注销该实例。 默认情况下，Eureka Server 也是一个Eureka Client，多个Eureka Server 之间通过复制的方式，来实现服务注册表的数据同步。 Eureka Client 会缓存服务注册表的信息，这种方法有一定的好处，首先，微服务不需要每次都请求服务端，从而降低了Eureka Server的压力。其次，即使Eureka Server的所有节点都宕掉，服务消费者依然可以通过缓存中的信息找到服务提供者并完成调用。 综上 ，Eureka 通过心跳检测，客户端缓存等机制，提高了系统的灵活性，可伸缩性和可用性。 搭建服务注册中心：首先需要在pom.xml 中添加依赖： 12345678910111213141516171819202122232425262728&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR3&lt;/spring-cloud.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 然后需要编辑启动类，需要在启动类上添加注解 @EnableEurekaServer注解，声明这是一个Eureka Server 123456789@SpringBootApplication@EnableEurekaServerpublic class MicroserviceEurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MicroserviceEurekaServerApplication.class, args); &#125;&#125; 编辑一下配置文件，执行一下端口，没有指定默认为8080 在默认情况下，服务注册中心也会将自己作为客户端来尝试注册自己，所以我们需要禁用它的客户端注册行为， 1234567891011server: port: 8761eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ eureka.cient.registerWithEureka: 由于该应用为注册中心，所以设置为false，代表不想注册中心注册自己。 eureka.client.fetchRegistry:由于注册中心的目的就是维护服务实例，他不需要去检索服务，（是否从注册中心获取注册信息 默认为true，由于这是一个单点的注册中心，不需要同步其他Eureka Server 的节点数据）所以也设置为false。 eureka.client.serviceUrl.defaultZone:设置与Eureka Server 交互的地址，查询服务和注册服务都需要依赖这个地址，默认是 http://localhost:9761/eureka/ 多个地址可以使用逗号分隔。 完成了上面的配置之后，启动服务，在浏览器中： http://localhost:8761 Eureka首页上展示了许多的信息，例如:当前实例的系统状态，注册到Eureka Server上的服务实例，常用信息，实例信息等。显然，当前还没有任何实例注册到Eureka Server。 注册服务提供者：首先是 pom.xml 1234567891011121314151617181920212223242526272829 &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR3&lt;/spring-cloud.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; &ensp;&ensp;&ensp;&ensp;然后启动类添加注解：@EnableDiscoveryClient 激活Eureka 中的DiscoveryClient 实现（自动化配置，创建DiscoveryClient接口 针对Eureka客户端的EurekaDiscoveryClient 实例）。 &ensp;&ensp;&ensp;&ensp;注解也可以改为使用@EnableEurekaClient 来代替 @EnableDiscoveryClient。在Spring Cloud中 服务发现组件有多种选择，例如：Zookeeper、Consul 等。@EnableDiscoveryClient 为各种服务组件提供了支持，该注解是spring-cloud-common项目的注解，是一个高度的抽象。而@EnableEurekaClient 表明是 Eureka的Client，该注解是spring-cloud-netflix项目的注解，只能与Eureka一起使用。当Eureka在项目的classpath中存在时，两个注解没有 区别。 123456789@SpringBootApplication@EnableDiscoveryClientpublic class MicroserviceSimpleProviderUserApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MicroserviceSimpleProviderUserApplication.class, args); &#125;&#125; &ensp;&ensp;&ensp;&ensp;然后编辑配置文件，首先需要另指定一个端口，或者使用默认的端口8080也可，避免端口冲突；可以为当前的服务指定一个服务名：spring.application.name=xxxxx ； 指定注册中心的地址： eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/ 12345678910spring: application: name: simple-provider-userserver: port: 8080eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka 可以 编写一个简单的controller 提供简单的RESTful 请求： 123456789101112131415161718192021@RestControllerpublic class UserController &#123; @Autowired private DiscoveryClient discoveryClient; @GetMapping("/index") public List&lt;String&gt; index()&#123; return discoveryClient.getServices(); &#125; @GetMapping("/getUser/&#123;id&#125;") public User getUser(@PathVariable("id") Long id)&#123; User user = new User(); user.setId(id); user.setUsername("王麻子"); user.setPassword("123456"); return user; &#125;&#125; 然后启动应用，重新在浏览器中运行 http://localhost:8761 观察当前应用是否注册成功。 高可用注册中心：&ensp;&ensp;&ensp;&ensp;在微服务架构这样的分布式 环境中，我们需要充分考虑发生故障的情况，在生产环境的各个组件需要进行高可用部署。前面部署的Eureka Server 并不适合生产环境，Eureka Client 会定时连接Eureka Server，获取注册表中的信息并缓存在本地。这样即使Eureka Server宕机也不会影响服务的调用，但是如果某些微服务也出现了问题，缓存如果不更新的话，就会影响到微服务的调用。因此 需要一个高可用的Eureka Server集群。 在单节点中，我们通过配置参数： 12eureka.cient.registerWithEureka=falseeureka.client.fetchRegistry=false 让注册中心不注册自己。 Eureka Server 设计一开始就考虑了高可用的情况。Eureka Server 的高可用实际上就是将自己作为服务向其他注册中心注册自己，这样就可以形成 一套互相注册的注册中心，以实现服务清单的互相同步。 下面我们就在原先注册中心的基础上，实现一个两个节点的注册中心。 首先新建一个原先的Eureka Server一样的模块，然后修改其中的配置文件： 123456789server: port: 1111spring: application: name: eureka-server-ha1eureka: client: serviceUrl: defaultZone: http://localhost:1112/eureka/ 123456789server: port: 1112spring: application: name: eureka-server-ha2eureka: client: serviceUrl: defaultZone: http://localhost:1111/eureka/ 两个注册中心互相注册，这样就实现了注册中心的高可用。 然后启动两个服务，http://localhost:1111 http://localhost:1112 在设置了多节点服务注册中心之后，服务提供方还需要做一些简单的配置才可以注册到注册中心， eg: 1234567spring: application: name: hello-serviceeureka: client: serviceUrl: defaultZone: http://localhost:1111/eureka/,http://localhost:1112/eureka/ 启动服务之后，当前的服务就被注册到了两个注册中心，此时一个注册中心宕机，还可以有另一个注册中心使用。 如果我们不想使用主机名来定义注册中心的地址，也可以使用IP地址的形式 ，需要在配置文件中声明： 123eureka： instance: preferIpAddress: true 服务发现与消费：在上面我们已经有了服务 注册中心和服务提供者，下面我们构建一个服务消费者，用来实现服务发现和服务消费的目标。其中服务发现由 Eureka Client来完成，服务消费则由Ribbon来完成。 Ribbon是一个基于HTTP和TCP的客户端负载均衡器，可以通过客户端配置的ribbonServerList服务端列表去轮询访问以达到负载均衡的目的。 当Eureka与Ribbon一起使用时，ribbonServerList服务清单列表就会被DiscoveryEnabledNIWSServerList重写。扩展成从Eureka注册中心获取服务端列表。同时他会用NIWSDiscoveryPing来代替IPing，将职责交给Eureka来确定服务端是否启动。Ribbon在Eureka服务发现的基础上实现了一套对服务实例的选择策略，从而实现对服务的消费。 下面就实现一个简单的消费者： 首先需要引入依赖 ： spring-cloud-starter-netflix-ribbon 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;&lt;/dependency&gt; 然后需要进行 关于 Ribbon 的设置： 12345678910111213141516@SpringBootApplication@EnableDiscoveryClientpublic class MicroserviceRibbonConsumer01Application &#123; public static void main(String[] args) &#123; SpringApplication.run(MicroserviceRibbonConsumer01Application.class, args); &#125; // 通过 @LoadBalanced来开启客户端负载均衡 @LoadBalanced @Bean public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 同时也需要配置一下配置文件，修改端口、为应用起一个服务名（注册到注册中心显示，服务调用时会用到），配置注册中心地址。 12345678910server: port: 9090spring: application: name: simple-consumer01eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 然后就需要写一个消费者测试实例了，在这里我们调用在上面的服务提供者，正常访问应该是：http://localhost:8080/getUser/1 在这里我们使用当前的应用来远程调用。 123456789101112131415161718/** * Created by wangchen on 2019/10/21 9:32 * Description: 远程调用Controller */@RestController@RequestMapping("/consumer")@Slf4jpublic class ConsumerController &#123; @Autowired private RestTemplate restTemplate; @GetMapping("/test") public User getUser()&#123; LOGGER.info("服务远程调用测试 开始"); return restTemplate.getForEntity("http://simple-provider-user/getUser/1",User.class).getBody(); &#125;&#125; 可以看到的是，在这里我们远程调用使用的时服务提供者的应用名称，而不是一个具体的地址，在服务治理框架中，这是一个非常重要的特性。 最后在浏览器中访问：http://localhost:9090/consumer/test 就会看到最终返回的结果与提供者返回的结果相同。 ribbon-consumer 应用的控制台可以看到如下信息： 123DynamicServerListLoadBalancer for client simple-provider-user initialized: DynamicServerListLoadBalancer:&#123;NFLoadBalancer:name=simple-provider-user,current list of Servers=[DESKTOP-G0ARIOG:8080],Load balancer stats=Zone stats: &#123;defaultzone=[Zone:defaultzone; Instance count:1; Active connections count: 0; Circuit breaker tripped count: 0; Active connections per server: 0.0;]&#125;,Server stats: [[Server:DESKTOP-G0ARIOG:8080; Zone:defaultZone; Total Requests:0; Successive connection failure:0; Total blackout seconds:0; Last connection made:Thu Jan 01 08:00:00 CST 1970; First connection made: Thu Jan 01 08:00:00 CST 1970; Active Connections:0; total failure count in last (1000) msecs:0; average resp time:0.0; 90 percentile resp time:0.0; 95 percentile resp time:0.0; min resp time:0.0; max resp time:0.0; stddev resp time:0.0]]&#125;ServerList:org.springframework.cloud.netflix.ribbon.eureka.DomainExtractingServerList@5763499c ribbon就是靠此信息来进行轮询访问，以实现基于客户端的负载均衡。 服务实例的健康自检在默认的情况下，Eureka客户端每隔30秒会发送一次心跳给服务端，告知他仍然存活。但是，在实际的情况中，可能会才存在这种问题，客户端表面上是存活的，但是当前的服务是不可用的。例如：当前的服务是存活的，但是无法访问数据库，或者当前应用需要远程调用第三方服务，但是第三方服务不可用或者不存在了，那么此时，这个应用也是不可用的。对于这些情况，应当告诉服务器当前应用的情况。 一个简单的健康自检：在这里，我们还是使用上面的两个例子，simple-provider-user, ribbon-consumer 稍微修改一下，服务提供者去请求数据库，(此处修改比较简单，不在此赘述)。 首先服务实例健康自检我们使用spring-boot-starter-actuator 模块，Spring Boot Actuator 模块主要用于系统监控，当应用程序整合了该模块之后，他会自动 提供多个服务端点，这些端点可以让外部看到应用程序的健康状况。 添加依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 修改配置文件 SpringBoot2.x 对actuator的配置做了一些修改 management.endpoints.web.base-path: WEB端点的基本路径，默认为actuator management.endpoints.web.exposure.include: //默认访问health，info端点，用*可以访问全部端点 123456management: endpoints: web: base-path: /actuator exposure: include: "*" 浏览器访问： http://localhost:8080/actuator/health 会看到下面的结果： 123&#123; "status": "UP"&#125; 实现应用健康自检：&ensp;&ensp;&ensp;&ensp;上面我们提到的问题，服务本身没有问题 ，但是服务的依赖存在问题，那么对于服务器的其他客户端来说，此时服务是不可用的。现在我们需要做的事情是： 让服务器可以自己检查，是否可以连接数据库；当数据库无法连接时，将状态告知服务器。 实现一个自定义的HealthIndicator ，根据是否能访问数据库来决定自己的健康状况。 12345678910111213141516/** * Created by wangchen on 2019/10/21 11:06 * Description: 实现自定义的健康检查 */@Componentpublic class MyHealthIndicator implements HealthIndicator &#123; @Override public Health health() &#123; if(HealthController.canVisitDB)&#123; return new Health.Builder().status(Status.UP).build(); &#125;else&#123; return new Health.Builder().status(Status.DOWN).build(); &#125; &#125;&#125; 123456789101112131415/** * Created by wangchen on 2019/10/21 11:10 * Description: 模拟测试是否可以连接数据库 */@RestControllerpublic class HealthController &#123; public static boolean canVisitDB = false; @GetMapping("/db/&#123;canVisitDB&#125;") public String setConnectState(@PathVariable("canVisitDB") Boolean canVisitDB) &#123; canVisitDB = canVisitDB; return "当前数据库连接状态：" + canVisitDB; &#125;&#125; 这样设置的话，通过 http://localhost:8080/db/false 可以修改 canVisitDB的值，相应的修改应用的健康状况。 接下来，服务的提供者需要把健康状况告诉服务器 ，还需要实现健康检查处理器，处理器会将应用的健康状况保存到内存中，状态一旦发生变化，就会重新向服务器进行注册，其他客户端将拿不到这些不可用的实例。 自定义健康检查处理器： 12345678910111213141516171819@Component@Slf4jpublic class MyHealthCheckHandler implements HealthCheckHandler &#123; @Autowired private MyHealthIndicator healthIndicator; @Override public InstanceInfo.InstanceStatus getStatus(InstanceInfo.InstanceStatus instanceStatus) &#123; Status status = healthIndicator.health().getStatus(); if(status.equals(Status.UP))&#123; log.info("数据库连接正常"); return InstanceInfo.InstanceStatus.UP; &#125;else&#123; log.info("数据库连接错误"); return InstanceInfo.InstanceStatus.DOWN; &#125; &#125;&#125; &ensp;&ensp;&ensp;&ensp;通过健康检查指示器的状态来返回不同的结果。eureka会启动一个定时器，定时刷新本地实例的信息，并且执行处理器中的getStatus方法，将服务的实例状态更新到服务器中，执行上面逻辑的服务器默认是30s执行一次，可以通过修改 eureka.client.instanceInfo-replicationIntervalSeconds配置。 基础架构：在简单的体验了Spring Cloud Eureka 通过简单的配置就可以实现强大的服务治理功能之后，我们来进一步了解一下Eureka 基础架构中的各个元素的通信行为。 服务提供者：服务注册：&ensp;&ensp;&ensp;&ensp;服务提供者在启动时候，会通过REST的请求的方式将自己注册到Eureka Server 上，同时携带自身服务的一些元数据信息。Eureka Server在接收到REST请求之后，将元数据信息存储在一个双层的MAP结构中，其中第一层的key 是 服务名，第二层的key为服务实例名。在服务注册的时候 需要注意一下参数：eureka.client.register-with-eureka=true 参数默认为true，若设置为false 不会启用注册操作。 服务同步：&ensp;&ensp;&ensp;&ensp;两个不同的eureka客户端分别注册到了两个不同的注册中心，也就是说两个客户端的信息分别被两个注册中心所维护。此时，由于两个注册中心互相注册为服务，当服务提供者发送注册请求到一个服务注册中心时，他会将该请求转发给其他的注册中心，从而实现注册中心之间的服务同步。通过服务同步，两个eureka客户端的服务信息可以从任意一台服务器上获取到。 服务续约：&ensp;&ensp;&ensp;&ensp;在完成注册服务之后，服务提供者会维持一个心跳契约来告诉eureka Server 我还活着，防止eureka server 的剔除任务将该服务从服务列表中剔除出去。 12eureka.instance.lease-renewal-interval-in-seconds=30eureka.instance.lease-expiration-duration-in-seconds=90 eureka.instance.lease-renewal-interval-in-seconds=30 参数用于定于服务续约任务的调用时间 默认为30s eureka.instance.lease-expiretion-duration-in-seconds=90 参数用于定于服务失效的时间 默认为90s 服务消费者：获取服务：&ensp;&ensp;&ensp;&ensp;此时，在服务注册中心已经注册了一个服务，且有两个实例。当我们启动服务消费者的时候，会发送一个REST请求到注册中心，获取到注册中心注册的清单，为了性能的考虑，eureka Server 会发送只读的服务清单到 客户端，同时该缓存清单每隔30秒更新一次。 &ensp;&ensp;&ensp;&ensp;获取服务是服务消费者的基础，为了确保该操作可以正常进行，需要确保参数 eureka.client.fetch-registry=true若希望修改缓存清单的更新时间 可以修改参数 eureka.client.registry-fetch-interval-seconds=30 参数进行修改。 服务调用：&ensp;&ensp;&ensp;&ensp;服务消费者在获取到服务清单之后，可以根据服务名获取到服务的具体实例以及对应的元数据信息，有了这些信息之后，客户端可以根据自己需要来决定来调用哪个服务实例。在ribbon中默认采用轮询的方式来调用，从而实现客户端的负载均衡。 &ensp;&ensp;&ensp;&ensp;对于访问实例的选择，Eureka 中存在region 和 zone的概念，一个region可以存在多个zone，每个服务的客户端需要注册到一个zone中，所以每个客户端对应一个region和一个zone。在请求服务的时候，优先选择同一个zone下的服务提供者，如果获取不到，就访问其他的zone。 服务下线：&ensp;&ensp;&ensp;&ensp;在服务的运行期间，我们可能关闭某一个服务的实例，对于关闭的服务实例，我们不希望有其他的服务来调用他。在客户端的实例中，当实例正常的关闭时，会触发一个REST请求去通知服务端，告诉服务注册中心我要下线了，服务注册中心将其状态置为DOWN，并把该下线时间传播出去。 服务注册中心：服务剔除：&ensp;&ensp;&ensp;&ensp;有些时候，服务实例并不是正常下线，可能是出现内存溢出，网络故障等原因服务不能正常工作，此时服务注册中心并没有收到服务下线的请求。为了将这些无法提供服务的实例剔除出去，服务注册中心会有一个定时任务每个60s运行一次将那些90s内没有续约的服务剔除出去。 自我保护：&ensp;&ensp;&ensp;&ensp;当我们在本地调试eureka程序时，基本上会看到这样一个现象，在服务注册中心的面板上会有下面这样的红色警告信息出现： &ensp;&ensp;&ensp;&ensp;实际上，这就是触发了eureka server 的自我保护。在服务注册之后呢，服务与server之间会维持一个心跳检测，来告诉eureka server 我还活着。Eureka Server 在运行期间会统计心跳失败的比例在15分钟内是否低于85%，如果出现低于的情况（在单机调试的时候很容易出现，生产环境通常是由于网络不稳定造成的），eureka server 此时会将注册的实例信息保护起来，让这些实例信息不会过期，尽可能的保护这些实例信息。但是如果此时，实例出现问题，客户端会拿到已经不存在的实例，会出现调用失败的情况。所以客户端需要有容错机制，比如：请求重试，断路器等。 eureka.server.enable-self-preservation=false 关闭保护机制，以确保注册中心将不可用的实例剔除出去。 配置详解：&ensp;&ensp;&ensp;&ensp;在Eureka服务治理体系中，主要分为服务端和客户端两个不同的角色，服务端为服务注册中心，客户端为各个提供接口的微服务应用。当我们构建了高可用的注册中心之后，该集群中所有的微服务应用和后续介绍的一些基础类应用（配置中心，API网关）都可以作为该体系下的微服务（erueka客户端），服务注册中心也是这样的，除了作为客户端之外还提供其他客户端注册实例信息的特殊功能。所以，eureka客户端下的配置信息存在于所有eureka server治理下的客户端实例中。 Eureka 客户端的配置信息主要分为两个方面： 服务注册相关的配置： 服务注册中心的实例地址、服务获取的间隔时间、可用区域等 p服务实例相关的配置： 服务实例的名称、IP地址、端口号、健康检查路径等 大多数情况下，我们并不需要修改他的配置信息。 服务注册类配置：指定注册中心：&ensp;&ensp;&ensp;&ensp;在前面我们的Eureka Server 中我们通过在服务端和客户端指定 eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/ 来实现指定注册中心 ，但是在实际的使用中，为了安全的考虑，一般都需要在注册中心加入安全校验。 实现方法，在服务端添加security的依赖，然后修改配置文件： 123456789101112131415161718server: port: 8761eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://$&#123;spring.security.user.name&#125;:$&#123;spring.security.user.password&#125;@$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ server: enable-self-preservation: falsespring: security: user: name: root password: root http://:@localhost:8761/eureka/ 的形式 。 需要注意的是 SpringBoot 2.X 中默认开启了csrf的认证，在这里我们手动关闭。 12345678910111213/** * Created by wangchen on 2019/10/23 11:24 * Description: */@EnableWebSecuritypublic class WebSecurityConfigurer extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; //开启认证 //为了使用 http://&#123;user&#125;:&#123;password&#125;@&#123;host&#125;:&#123;port&#125;/eureka/ 这种方式登录 所以必须是 httpBasic http.csrf().disable().authorizeRequests().anyRequest().authenticated().and().httpBasic(); &#125;&#125; 客户端配置： 1234567891011121314151617181920server: port: 8080eureka: client: serviceUrl: defaultZone: http://root:root@localhost:8761/eureka/ fetch-registry: true register-with-eureka: true registry-fetch-interval-seconds: 30 instance: lease-renewal-interval-in-seconds: 30 lease-expiration-duration-in-seconds: 90management: endpoints: web: base-path: /actuator exposure: include: "*" 其他重要配置信息：以下参数以 eureka.client 为前缀 参数名 说明 默认值 enabled 启用eureka客户端 true registry-fetch-interval-seconds 从Eureka服务端获取注册信息的间隔时间（秒） 30 fetch-registry 是否从Eureka服务端获取注册信息 true register-with-eureka 是否要将自身的实例信息注册到服务端 true 服务实例类配置：eureka.instance 为前缀： 元数据：&ensp;&ensp;&ensp;&ensp;Eureka客户端向服务注册中心发送注册请求时，用来描述自身服务信息的对象，其中包含了一些标准化的元数据，比如：服务名称，实例名称，实例IP，实例端口等用于服务治理的重要信息，以及其他一些用于负载均衡策略或是其他特殊用途的自定义元数据信息。 &ensp;&ensp;&ensp;&ensp;元数据会保存在服务器的注册表中，并且使用简单的方式与客户端共享。在正常情况下，自定义的元数据并不会改变客户端的行为。 1234567@Autowired private DiscoveryClient discoveryClient; @GetMapping("/getInstanceInfo") public List&lt;ServiceInstance&gt; showInfo()&#123; return discoveryClient.getInstances("simple-provider-user"); &#125; 实例名配置：&ensp;&ensp;&ensp;&ensp;实例名是区分同一服务中不同实例的唯一标识。在Netflix Eureka 的原生实现中，实例名默认采用主机名，这样设置使得在同一主机上无法启动多个相同的服务实例。在Spring Cloud Eureka 的默认配置中，针对同一主机启动多实例的情况 ，对实例名的默认命名采用了更为合理的扩展 ： ${spring.cloud.client.hostname}:${spring.application.name}:${spring.application.instance_id}:${server.port} 对于实例名的命名规则，我们可以通过配置 eureka.instance.instance_id参数来进行配置。 当我们在本地启动一个服务的多个实例的时，必然会导致端口冲突，可以使用随机数来指定端口 ： 1server.port = $&#123;random.int[10000,19999]&#125; 或者 server.port = 0 来指定随机端口 但是这时我们发现注册到Eureka Server的实例名都是相同的，这样会导致只有一个实例可以正常提供服务，这时可以通过指定实例名来解决： 1eureka.instance.instance_id=$&#123;spring.application.name&#125;:$&#123;random.int&#125; 端点配置：&ensp;&ensp;&ensp;&ensp;在元数据信息中存在一些URL的配置信息，比如：homePageUrl、statusPageUrl、healthCheckUrl 他们分别代表了应用主页Url、 状态页的Url、健康检查页的Url。其中状态页和健康检查页的Url使用的时Spring Boot Actuator的模块提供的/info 和 /health 端点。为了服务的正常运作，我们必须确保Eureka的客户端 /health 是一个能够被访问到的地址，否则服务注册中心不会根据应用的健康检查来更新状态。 大多数情况下，我们并不需要修改这些配置。 123456management: endpoints: web: base-path: /actuator exposure: include: "*" 健康检测：&ensp;&ensp;&ensp;&ensp;默认的情况下，Eureka各个服务实例的健康检测并不是通过spring-boot-actuator模块的/health实现的，而是依靠客户端心跳的方式来保持服务实例的存活，在Eureka Server的服务续约和剔除下，客户端都会处于UP的状态，除非在一段时间内没有心跳维持，服务端将其剔除。 &ensp;&ensp;&ensp;&ensp;默认的心跳检测可以有效检测客户端是否存活，但是客户端存活并不一定可以正常的工作，可能此时客户端无法连接到数据库….. &ensp;&ensp;&ensp;&ensp;在SpringCloudEureka中，我们可以通过简单地配置，把Eureka的客户端检测交给spring-boot-actuator模块的health端点。 首先需要引入spring-boot-actuator模块 修改配置文件 eureka.client.healthcheck.enabled=true 源码地址：https://github.com/handsome-owner/springcloud_test.git 参考链接：SpringBoot Actuator 监控介绍 SpringCloud微服务实战 SpringCloud与Docker微服务架构实战]]></content>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务的构建-SpringBoot]]></title>
    <url>%2F2019%2F10%2F10%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%84%E5%BB%BA-SpringBoot%2F</url>
    <content type="text"><![CDATA[微服务构建 SpringBoot &ensp;&ensp; &ensp;&ensp;SpringCloud的出现，可以说是对微服务架构的巨大支持，和强有力的技术后盾。他是一个解决微服务架构实施的综合性解决框架，整合了诸多被广泛实践和证明过的框架作为实施的基础部件，又在该体系上创建了一些优秀的边缘组件。 SpringCloud 简介：&ensp;&ensp; &ensp;&ensp;Spring Cloud 是一个基于 SpringBoot的微服务架构开发工具。他为微服务架构中涉及到的配置管理、服务治理、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群管理状态等操作，提供了一种简单的开发方式。 &ensp;&ensp; &ensp;&ensp;SpringCloud包含多个子项目，针对分布式系统中涉及到的多个不同开源产品，有以下几个组件： Spring Cloud Netflix: 核心组件： Eureka： 服务治理组件，包含服务注册中心、服务注册和发现机制的实现。 Hystrix：容错管理组件，实现断路器模式，帮助服务依赖中出现的延迟和为故障提供强大的容错能力。 Ribbon：客户端负载均衡的服务调用组件 Feign：基于Ribbon和Hystrix的声明式服务调用组件 Zuul： 网关组件，提供智能路由、访问过滤等功能。 Archaius： 外部化配置组件 Spring Cloud Bus: 事件 消息总线，用于传播集群中的状态变化或事件，以触发后续的处理，比如：用来动态刷新配置等。 Spring Cloud Cluster：针对Zookeeper、Redis、Hazelcast、Consul的选举算法和通用状态模式的实现。 Spring Cloud Cloudfoundry：与Privotal Cloudfoundry的整合支持。 Spring Cloud Consul : 服务发现和配置管理工具 Spring Cloud Stream：通过Redis、Rabbit、或者kafka 实现的消费微服务，可以通过简单的声明式模型来发送和接收消息。 Spring Cloud Security：安全工具包，提供在Zuul中代理对OAuth2 客户端请求的中继器。 Spring Cloud Zookeeper：基于Zookeeper的服务发现和配置管理组件。 Spring Cloud Config：配置管理工具，支持使用Git来存储配置内容，可以使用它实现应用配置的外部化存储，并支持客户端配置信息刷新，加密/解密配置内容等。 ……. 微服务构建：SpringBoot：&ensp;&ensp; &ensp;&ensp;构建微服务的基础框架：SpringBoot &ensp;&ensp; &ensp;&ensp;SpringBoot 是SpringCloud的基础，同样，也是一个非常优秀的框架。支持 自动化配置、快速开发、轻松部署，非常适合作为微服务架构中各项具体微服务的开发框架。 框架简介：&ensp;&ensp; &ensp;&ensp;对于Spring 框架的初学者来说，经常会因为其繁杂的配置文件而却不。对于很多老手来说，每次新构建项目，总是需要重复复制粘贴一些差不多的配置文件这样枯燥乏味的事。或者，我们可以通过Maven等构件工具来创建针对不同场景的加脚手架工程，在需要新建项目时，通过这些脚手架来初始化我们自定义的标准工程，并根据简单修改以达到简化原有配置过程的效果。这样的手段，虽然减少了工作量，但是这些配置依然大量散布在我们的工程中，大部分情况下，我们并不会修改其中的内容，但为什么还要反复出现在我们的工程中呢？ &ensp;&ensp; &ensp;&ensp;SpringBoot的出现可以有效改善这类问题，SpringBoot的出现并不是要重写Spring或者代替Spring，而是希望通过大量的自动化配置的方式来简化Spring原有样板化的配置，使得开发者可以快速构建应用。 &ensp;&ensp; &ensp;&ensp;除了解决配置问题之外呢，SpringBoot还通过了一系列的Starter POMs的定义，让我们整合各项功能的时候，不需要在Maven的pom.xml中维护那些错综 复杂的依赖关系，而是通过类似模块化的Starter模块定义来引用，使得依赖管理变得更简单。 &ensp;&ensp; &ensp;&ensp;在当前容器化大行其道的时代，Spring Boot除了可以很好的融入Docker之外，其自身就支持嵌入式的Tomcat，Jetty等容器。所以，通过Spring Boot构建的应用不再需要安装Tomcat，将应用打成war包，再部署到Tomcat这样复杂的构建与部署工作。只需要将应用打成jar包，并通过java -jar的命令直接运行就能启动一个标准化的WEB应用，这使得SpringBoot应用变得更轻便。 &ensp;&ensp; &ensp;&ensp;SpringBoot对构建 ，部署做了这么多的优化，在开发环节也有许多的优化。整个SpringBoot的生态系统都使用到了Groovy，很自然地，我们可以使用Groovy Gradle来开发SpringBoot应用。 快速开始：下面我们创建一个简单的Spring Boot 基础项目，并且实现一个简单的RESTful API。 使用工具： jdk8、maven3.5+、idea开发 eg: pom.xml文件: 只需要引入 spring-boot-starter-web 全栈WEB开发，包含tomcat 以及 Spring MVC 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.9.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.wc.test&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-hello&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-hello&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 实现RESTful API : 12345678@RestControllerpublic class HelloController &#123; @GetMapping("/sayHello") public String sayHello()&#123; return "hello world"; &#125;&#125; 默认的端口是 8080 只需要在浏览器输入 localhost:8080/sayHello 就会看到返回的 hello world 。 配置详解：&ensp;&ensp; &ensp;&ensp;在上面的例子中，我们只是使用了很少的代码就实现了一个RESTful API。 &ensp;&ensp; &ensp;&ensp;在 src/main/resources 下面是SpringBoot项目的配置目录，在当前目录下进行应用的个性化配置。 &ensp;&ensp; &ensp;&ensp;在当前目录下存在一个application.properties文件，此文件是该应用的配置文件，我们一般使用yml文件，将其改名为application.yml ，可以在当前文件中定义文件的端口号，数据库连接信息，日志级别等各种配置信息。例如：我们可以通过 server.port=8888，来修改端口，spring.application.name=hello 来修改应用名。 YAML（/ˈjæməl/，尾音类似 camel 骆驼）是一个可读性高，用来表达数据序列化的格式。YAML 参考了其他多种语言，包括： C 语言、 Python、Perl，并从 XML、电子邮件的数据格式（RFC 2822）中获得灵感。Clark Evans 在 2001 年首次发表了这种语言 ，另外 Ingy döt Net 与 Oren Ben-Kiki 也是这语言的共同设计者 。当前已经有数种编程语言或脚本语言支持（或者说解析）这种语言。 YAML 是 “YAML Ain’t a Markup Language”（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时， YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言，但为了强调这种语言以数据做为中心，而不是以标记语言为重点，而用反向缩略语重命名。 eg: 12345server: port: 8888spring: application: name: hello 自定义参数：我们可以在配置文件 application.yml 中添加一些自定义的参数： 123book: name: SpringCloud实战 price: 25.5 在应用中可以通过@Value注解来加载这些自定义参数： 1234567891011121314@RestControllerpublic class HelloController &#123; @Value("$&#123;book.name&#125;") private String bookName; @Value("$&#123;book.price&#125;") private double bookPrice; @GetMapping("/getBook") public Book getBook()&#123; return new Book(bookName,bookPrice); &#125;&#125; @Value注解加载属性值的时候可以支持两种表达式来配置， 一种是上面的这种形式 plcaeHolder 格式为：${…} 大括号内为 placeHolder 另外一种就是SpEL表达式，格式为 #{…} 大括号内为SpEL表达式。 参数引用：在application.yml 中的各参数之间可以通过使用placeHolder的方式来引用，就像下面的配置一样： 1234book: name: SpringCloud实战 price: 25.5 description: $&#123;book.name&#125; 价格： $&#123;book.price&#125; 使用随机数：&ensp;&ensp; &ensp;&ensp;在一些情况下，我们希望有些参数在每次加载的时候不是一个固定的值，比如：秘钥 服务端口等。在Spring Boot的属性配置文件中，可以通过${random} 配置来产生随机的int值，long值，或者string字符串。这样我们可以很容易的通过配置随机生成属性，而不是在程序中通过编码来实现这些逻辑。 1234567891011#$&#123;random&#125;的配置方式主要有以下四种：#随机字符串：random.str: $&#123;random.value&#125;#随机intrandom.int: $&#123;random.int&#125;#随机longrandom.long: $&#123;random.long&#125;#10以内的随机数random.int2: $&#123;random.int(10)&#125;#10~20的随机数random.int3: $&#123;random.int(10,20)&#125; 可以设置应用端口等场景，以避免在本地调试的时候出现端口冲突的错误。 命令行参数：&ensp;&ensp; &ensp;&ensp;打成jar包的应用，可以通过java -jar的 方式启动，可以在命令行中指定应用的参数 eg: java -jar xxx.jar –server.port=8888，将启动后应用的端口设置为8888。 &ensp;&ensp; &ensp;&ensp;在用命令行的方式启动应用时，连续的两个减号 – 就是对application.properties 中属性值进行赋值的标识。等价于在配置文件中设置server.port=8888。 通过此特性，使得应用的属性在启动前是可变的。 多环境配置：&ensp;&ensp; &ensp;&ensp;我们在开发应用的时候，不同大的环境（开发、测试、生产）需要不同的配置值 （数据库地址、服务器端口等），如果不同的环境需要不断的修改配置文件再打包的话，将是非常繁琐且容易发生错误的事。 &ensp;&ensp; &ensp;&ensp;对于多环境的支持，各种构件工具或者框架的解决思路都是一致的，通过配置多份不同环境的配置文件，再通过打包命令指定需要打包的内容之后进行区分打包，SpringBoot也是这样的思路，其实现起来更加简单。 &ensp;&ensp; &ensp;&ensp;在SpringBoot中，多环境的配置文件需要满足application-{profile}.yml 这样的形式，其中{profile}是对应环境的标识。如下所示： application-dev.yml 开发环境 application-test.yml 测试环境 application-prod.yml 生产环境 至于需要指定使用哪个环境，需要在application.yml 中指定： 123spring: profiles: active: test 我们可以在application.yml中配置通用的内容，然后在不同的环境配置文件中配置需要变动的配置。 加载顺序：&ensp;&ensp; &ensp;&ensp;我们现在已经知道，我们将配内容都放在了项目的配置文件中，同时支持多环境配置。但是，在业务复杂之后，往往不需要让开发人员知道测试或是生产环境的细节，而是希望各个环境的负责人来集中维护这些信息，如果是以这样的方式存储配置内容，对于不同环境配置的修改就不得不去获取工程内容来修改这些配置内容，当应用非常多的时候，就会非常不方便，同时，配置内容对开发人员都可见，这本身就是一种安全隐患。 对此出现了很多配置内容外部化的框架和工具，Spring Cloud Config 就是其中之一。 为了能够更合理的重写各属性的值，SpringBoot使用下面的属性加载顺序。 在命令行中传入的参数 SPRING_APPLICATION_JSON 中的属性，SPRING_APPLICATION_JSON是以json格式配置在系统环境变量中的内容。 java:comp/env 中的jndi属性 java的系统属性，可以通过System.getProperties() 获得内容 操作系统的环境变量 通过random.* 配置的随机属性 位于当前jar包之外，针对不同的application-{profile}.yml 配置文件内容 位于当前jar包之内，针对不同环境的 application-{profile}.yml 位于当前jar包之外的，application.yml内容 位于当前jar包之内的，application.yml内容 在@Configuration注解修改的类中 通过@PropertySource注解定义的内容。 应用默认属性，使用SpringApplication.setDefaultProperties定义的内容。 有限按照上面的顺序由高到低，数字越小优先级越高。 监控与管理：&ensp;&ensp; &ensp;&ensp;在微服务的架构中，我们将原本一个复杂的应用拆分为多个提供不同服务的应用，虽然各个因应用的内部因分解而得以优化，但是由于部署的应用成倍的增加，使得系统的维护复杂度大大提升。这样系统集群中出现故障的评率也越来越高，虽然在高可用机制的作用下，单个应用的故障不会影响系统的对外服务，但是出现故障的应用需要被及时的处理才能让系统保持健康可用的状态。 &ensp;&ensp; &ensp;&ensp;我们需要一套自动化的监控运维机制，而这套机制的运行基础就是不断的收集各个微服务应用的各项指标情况，并根据这些指标信息来指定监控和预警规则，更进一步做到一些自动化的运维操作等。需要一套专门植入各个微服务应用的接口供检测系统采集信息，比如：环境变量、垃圾收集信息、内存信息、线程池信息等。 &ensp;&ensp; &ensp;&ensp;SpringBoot中存在一个这样的模块 spring-boot-starter-actuator。引入该模块可以为SpringBoot的应用提供一些列用于监控的端点。同时Spring Cloud 在实现各个微服务组件的时候 ，进一步为该模块做了不少 扩展，比如：为原生端点增加了更多的指标和度量信息（比如 在整合Eureka的时候 会为/health端点增加相关的信息），并且根据不同的组件还提供了更多用空的端点。（比如：为API网关组件 Zuul 提供了 /routes 端点来返回路由信息）。 初识actuator：首先需要在pom.xml中添加依赖 spring-boot-starter-actuator 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 增加了该模块之后，重新启动应用，可以看到下面的输出: 12019-10-11 10:19:35.858 INFO 15984 --- [ main] o.s.b.a.e.web.EndpointLinksResolver : Exposing 2 endpoint(s) beneath base path &apos;/actuator&apos; 在浏览器中访问： localhost:8888/actuator 可以看到下面的输出结果： 123456789101112131415161718192021222324&#123; "_links": &#123; "self": &#123; "href": "http://localhost:8888/actuator", "templated": false &#125;, "health": &#123; "href": "http://localhost:8888/actuator/health", "templated": false &#125;, "health-component": &#123; "href": "http://localhost:8888/actuator/health/&#123;component&#125;", "templated": true &#125;, "health-component-instance": &#123; "href": "http://localhost:8888/actuator/health/&#123;component&#125;/&#123;instance&#125;", "templated": true &#125;, "info": &#123; "href": "http://localhost:8888/actuator/info", "templated": false &#125; &#125;&#125; 我们可以看一下health 的结果： http://localhost:8888/actuator/health 123&#123; "status": "UP"&#125; 没有引入其他模块时，改端点的内容比较简单，后续我们在使用Spring Cloud 的时候，他的返回就会变得非常丰富。这些内容将帮助我们制定更加给个性化的监控策略。 参考资料：SpringCloud微服务实战 SpringCloud微服务架构实践]]></content>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是微服务]]></title>
    <url>%2F2019%2F10%2F09%2F%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[什么是微服务？&ensp;&ensp;&ensp;&ensp;微服务是一种架构风格，将单体应用划分为小型的服务单元，微服务之间使用HTTP的API进行资源的访问和操作。&ensp;&ensp;&ensp;&ensp;微服务架构的系统是一个分布式的系统，按业务进行划分为独立的服务单元，解决单体系统的不足，同时也满足越来越复杂的业务需求。 单体架构：什么是单体架构：&ensp;&ensp;&ensp;&ensp;单体应用就是将应用程序的所有功能都打包成一个独立的单元。 &ensp;&ensp;&ensp;&ensp;在软件设计的时候经常提到和使用经典的3层模型，即表现层，业务逻辑层，数据访问层。虽然在软件设计中划分了3层模型，但是对业务场景没有划分，一个典型的单体架构就是将所有的业务场景的表现层，业务逻辑层，数据访问层放在一个工程中最终经过编译，打包，部署在一台服务器上。此时服务架构如图： 单体架构存在的优点：1.便于开发:只需借助IDE的开发、调试功能即可完成。 2.易于测试:只需要通过单元测试或浏览器即可完成测试。 3.易于部署:打包成单一可执行jar包，执行jar包即可完成部署。 单体架构存在的不足：&ensp;&ensp;&ensp;&ensp;应用程序随着业务需求的迭代，功能的追加扩展,最终成为一个庞然大物。变得更加复杂，逻辑耦合严重，难以理解，团队开发 人员职责不清，部署困难，回归测试成本巨大，交付效率大大降低，总结下来，单体应用有以下缺点: 1. 复杂性高 代码难以理解在业务规模和团队规模发展的一定阶段，这些不足表现的更加明显，单体架构的不足首先表现在复杂性上, maven模块增多，多个模块耦合在一起，代码结构混乱，使得团队成员没有一个人理解整个代码逻辑； 难以理解导致代码质量低，复杂性进一步增加难以理解导致代码复用度降低，因为你不知道哪些可以复用的；即便修改，影响范围也不好确定，这导致这样开发宁愿新建一个新方法和新的类，进一步导致重复代码越积越多； 代码难以被修改和重构不理解代码当然也就写不出高内聚低耦合的代码，和代码质量持续下降；复杂性进一步增加随着复杂度的增加，耦合度越来越高，代码牵一发而动全身，代码已经很难修改和重构了 团队职责不清晰高度耦合的单体工程使得逻辑边界模糊不清，新的业务需求开发任务无法有效分配到人，团队人员职责不清晰，沟通成本增加。 2.交付效率低 构建和部署耗时长，难以定位问题，开发效率低代码量比较庞大，首先是编译耗时变长，开发调试将大部分时间花在重新编译上，代码量的增加又很难定位bug，导致开发效率进一步降低，在代码合并过程中极易遇到代码冲突，又花上不少时间用在解决代码冲突上；这都是导致开发效率低下的因素； 代码复杂和变更影响难以理解，需要数天完成全量测试当我们开发完一个新的功能或者修复一个bug，代码的变更影响是很难预估的，所以每次发布之前都要进去全量功能的回归测试； 全量部署耗时长、影响范围广、风险大，发布频次低正因为这种全量部署耗时长、影响范围广、风险大，导致我们将很多功能和修复聚集在一起进行开发完成，这导致了产品发布频次降低，新的功和更换的体验能不能及时呈现给用户，甚至被竞争对手赶超。 3.伸缩性(scalable)差 单体只能按整体横向扩展，无法分模块垂直扩展 IO密集型模块和CPU密集型模块无法独立升级和扩容业务模块对资源的需求是不一样的，由于所有模块部署到一起，单体架构IO密集型模块和CPU密集型模块无法独立升级和扩容的，比如图片压缩，加解密这些 都是cpu资源密集的应该升级CPU，而IO密集型的模块比如日志收集服务IO操作比较多需要更大的内存，使用比如SSD性能更好的磁盘。 4. 可靠性差 一个bug有可能引起整个应用的崩溃由于所有模块都是部署在一个实例中，一个bug会引起整个应用的崩溃，比如一个不重要的模块的内存泄露就将会导致所有应用实例一个个crash掉 5.阻碍技术创新 受技术栈限制 团队成员使用同一框架和语言，模块得不到拆分，不能使用新的语言和框架。 升级和变革技术框架变得困难当有符合业务场景的新技术产生或者新版本时，升级和变革技术框架所带来的重构成本和风险变革很高。 尝试新语言变得困难想尝试新的语言也变得很困难，因为开发成本的上升，重构和新需求迭代无法协调，所以最终只能是妥协继续使用原来的框架和语言 那么如何解决单体的不足呢，通过迁移到微服务架构来解决，我们看一下什么是微服务。 微服务：什么是微服务架构：&ensp;&ensp;&ensp;&ensp;微服务架构:将单体应用拆分为多个高内聚低耦合的小型服务，每个小服务运行在独立进程，由不同的团队开发和维护，服务间采用轻量级通信机制，独立自动部署，可以采用不同的语言及存储。 &ensp;&ensp;&ensp;&ensp;我们通过上图来看下单体架构到微服务架构的对比。此图是一个简单电商单体到微服务架构的演进图，单体架构整个团队维护开发一个大工程及一个单库，到了微服务架构，用户请求经过API Gateway被路由到下游服务，服务之间以轻量级通信协议进行通信，服务通过注册中心发现彼此，每个服务都有专门的开发维护团队，每个服务对应独立的数据库，服务独立开发，独立部署和上线。 接下来我们总结下微服务的优点。 微服务的优点：1.易于开发与维护 微服务相对小，易于理解 启动时间短，开发效率高 2.独立部署 一个微服务的修改不需要协调其它服务 3.伸缩性强 每个服务都可以在横向和纵向上扩展 每个服务都可按硬件资源的需求进行独立扩容 4.与组织结构相匹配 微服务架构可以更好将架构和组织相匹配 每个团队独立负责某些服务，获得更高的生产力 5.技术异构性 使用最适合该服务的技术 降低尝试新技术的成本 微服务的挑战&ensp;&ensp;&ensp;&ensp;没有任何技术是银弹，微服务也是如此 ,都或多或少有一些缺点和问题。那么我们就必须针对这些问题一一解决，也是我们接下来章节重点去做的. 我首先面对就是要将单体拆分成多个服务。 1.服务拆分 微服务拆分原则:领域模型、限定上下文、组织架构、康威定律现实中没有一个具体明确的方法可以将拆分一步到位，而是遵守一定的原则，比如根据领域模型、组织架构、单一职责这些进行拆分在拆分的过程中还要结合经验判断，并且随着需求迭代，架构持续优化演进，优化服务的拆分。 每个微服务拥有独立数据库服务拆分的同时还要考虑到存储数据库也要独立，当多个服务直接读写数据库中同一张表时，对这些表做任何改动都需要协调这些相关服务的部署。这一点违背了服务相互独立这一原则。共享的数据存储很容易不经意间造成耦合。每个服务需要有自己的私有数据。比如订单表被订单服务和商品服务所共享，商品服务单独做统计并不知道自己一天多少商品被卖出，不知道哪些数据由本服务产生的，就无法进行技术产品规划，对表结构的修改也要通知多个服务，这是所不能容忍的。每个服务需要自己的数据库，但这些数据库可共置在一台共享的数据服务器上，数据库私有的重点在于不应让服务知道其他服务底层数据库的存在。可用一台共享数据服务器先开始开发，以后如果数据量和并发量变大，服务器可以进行隔离。服务器隔离后，只要更改配置即可将不同服务的数据库隔离起来。 微服务之间确定服务边界,通过共享模型建立联系每个微服务都具备自己的业务能力，那么服务之间交互的部分即是服务边界； 确定服务边界也是一个难题，需要对自己的产品和业务有足够的了解才能确定最自然的服务边界。确定服务边界坚持的原则是要高内聚弱耦合，弱耦合就是一个服务与其他服务的任何通信都应通过公开暴露的接口（API、事件等）实现，这些接口需要妥善设计以隐藏内部细节。这样我们的服务之间保持独立，在未来我们可以轻松重构，高内聚力就是密切相关的多个功能应尽量包含在同一个服务中，这样可将服务之间的干扰降至最低。 2.数据一致性 在单体架构中，我们通过数据库事务完成的操作 放在分布式微服务架构下无法完成了，因为实例被部署不同服务器上,比如订单服务进行下单操作，下单操作和扣减库存应该放在同一个事务中，在微服务架构下，下单操作和扣库存操作被分布在不同服务器上，就需要进行分布式事务操作,而分布式事务具有延迟较高、nosql数据库不支持等缺点。这些缺点导致分布式事务无法应用到微服务中在微服务场景下，我们通常使用最终一致性来代替强一致性。 可靠性事件模式 补偿模式-sagas模式 3.服务通信 通信技术方案: RPC vs REST vs 异步消息 RPC、REST API、异步消息，异步消息我们可以借助一些消息队列框架来实现比如kafka、rabbitMQ，那现在我们说下rpc和使用http协议的类似REST API之间 如何选择，TTP的好处是方便调试、跨语言、门槛低、广泛接受，同样缺点是协议文档不好维护，协议较为繁琐，性能较TCP要差是http协议的不足。Rpc通信通常基于Tcp，常用的技术选型是thrift、grpc、dubbo，像thrift、grpc需要定义idl文件，通过idl文件来生成java代码，通过rpc的好处是IDE友好，有代码提示，协议维护在代码中，传参和响应结果都通过代码可以知道。但同时也有缺点比如很多rpc方案不知道跨语言，所支持的语言有限，需要定义和维护idl文件，且有一定的学习成本，另外rpc不容易方便的调试和测试 服务注册和发现 在服务实例变化不定的环境中，用硬编码指定IP地址的方式是行不通的，需要通过某种发现机制让服务能相互查找。这就需要我们将我们的服务信息注册到一个分布式存储中，这些服务信息就叫做服务注册表服务注册表可以作为信息的权威来源。其中包含有关可用服务的信息，以及服务网络位置比如ip、端口号这些信息。那借助什么组件进行实现呢，一般有Eureka和zookeeper，除此之外我们还可以借助etcd，consul，redis这些。 负载均衡 有了注册发现功能，客户端通过服务注册表发现实例清单并决定要连接哪个实例，在客户端做负载均衡，基于客户端做负载均衡相比服务端负载均衡有诸多好处：首先节省了硬件均衡设备，减少了运维成本，其次可以实现多种负载均衡策略比如响应感知的负载均衡策略。 4.服务网关 API Gateway我们的微服务如果和终端用户交互，势必要考虑身份认证、安全防御等这些方面，如果每个微服务都与终端用户打交道，那么这些方面代码需要拷贝多份植入到每个微服务业务代码中。这造成了业务代码和身份认证代码的耦合，降低了代码的复用性。这就需要在网络边界实现一个服务网关（这里的网络边界可以认为是内网和外网之间的边界），将身份认证，安全防御，流量控制这些功能放到服务网关中，向业务服务屏蔽网络边界服务的细节，使得业务服务专注于业务逻辑的开发维护和测试。 为前端服务的后端(Backends For Forntends)服务网关可以根据终端产品形态来划分，比如公共API,桌面客户端，移动客户端分别对应一个服务网关，而服务网关可以是API Gateway只输出api，或者是为前端服务的后端，这里的为前端服务的后端，比如将来自多个服务的数据聚合到一起返回给前端。 身份认证、路由服务、限流防刷、日志统计 5.高可观察 健康检测、集中监控 每个服务和使用的组件都有提供健康检测机制，使得我们可以及时发现异常的节点，然后做出判断和调整，将所有的监控指标进行聚合输出可视化图表和界面帮助我们快速直观发现问题。 日志聚合及检索 比如在电商app我们发现无法进行下单操作，在分布式架构下，日志散落在多个服务多个服务器中，我们不知道错误日志打在哪台服务器上，如果每台服务器去登陆去看是极其低效的。这要求我们做到日志格式标准化，并通过一些手段聚合到一起进行检索查询。同时可跨越所有服务、特定的某个服务，或服务的某个实例搜索日志；将日志发送至集中化日志系统所用的代码可包含在共享库中或通过代码脚手架提供。 分布式追踪 在微服务架构场景中，一个客户端发起的请求要经过多个服务的调用最终聚合数据结构返回给客户端，但我们不知道这个请求不知道经过哪些服务，调用哪个服务出现了问题，每个服务的输入输出是什么，这给我们定位问题带来了困扰，除此以外，如果一个请求耗时较长，我们不知道到底哪个服务耗时最长，好有针对性的性能优化。随着架构的演进，我们在架构设计规划时需要知道 服务之间的依赖关系，这有需要什么技术来实现呢，这就是我们要介绍的分布式追踪，分布式追踪借助关联id，在请求源头创建这个关联id，并且在服务间进行透传，最终将关联id等信息聚合到一起进行查询分析。 6.可靠性&ensp;&ensp;&ensp;&ensp;在讲单体的过程中，我们讲到，一个业务模块的内存泄露会导致整个进程退出。 在微服务场景下，如果一个服务出现内存泄露是不会影响 没有依赖关系的服务的。 但是却可以因为该异常服务的僵死或不可用造成上游服务线程hang住，进而产生级联效应，故障进一步向上游传播。 流量控制，超时控制 可靠性技术通过流量的控制和超时控制，保证服务消费者不被下游服务拖慢，及时对业务线程循环复用。 舱壁隔离，熔断机制 熔断是指服务调用出错次数在一定时间达到一定数量，自动关闭对该服务的调用开关，改为返回错误或者将请求转交给降级方法，降低资源耗尽的风险，当服务不可用时，作为服务消费者应该对接口方法编写一个降级方法。 服务降级, 幂等重试 由于服务间通信是通过网络传输的，网络异常和网络分区故障 就会经常出现，我们遇到这种情况可以进行调用重试，重试时要注意两点，一个是接口必须是幂等的，无论运行一次或多次，最终结果必须相同。幂等性保证了重试不会产生负面影响。在重试过程时休眠时间应该是指数增长的，否则会产生惊群效应，比如：故障后的服务恢复上线后，如果有大量其他服务正在同一个重试窗口内重试，此时很容易给系统造成巨大压力。 参考链接： 学习微服务首先了解为什么使用微服务 什么是微服务]]></content>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo来搭建个人网站]]></title>
    <url>%2F2019%2F09%2F30%2F%E4%BD%BF%E7%94%A8hexo%E6%9D%A5%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[hexo是什么？ Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 使用hexo的前置准备： 需要在本机有 git node的环境 Node.js 下载地址 直接下载安装版本 会自动配置环境变量 同时安装npm git 下载地址 配置环境变量 Typora 一款好用的md编辑器 需要有一个github的账号 同时新建一个仓库 创建一个repo，名称为yourname.github.io, 其中yourname是你的github名称，按照这个规则创建才有用。 新建一个文件夹 hexo来保存hexo的文件 同时也是以后md文件的存放地址 开始安装hexo：进入到上面新建的目录中，然后右键 git bash here 首先替换npm的国内镜像源： npm config set registry=&quot;http://registry.cnpmjs.org&quot; 开始安装了： npm install -g hexo 会在文件夹中出现新的文件 hexo init 安装依赖包，hexo 会自动在自动在文件夹中建立网站所需的文件。 npm install 生成静态页面到public目录（静态博客就在这个位置） hexo generate 开启预览访问端口，默认端口4000 可在浏览器中查看 hexo server 在浏览器中访问： localhost:4000 ,可以进行预览。每次变更_config.yml 文件或者上传文件都可以现在本次查看一下 部署到github:hexo d 在此之前需要先修改根目录下的 _config.yml 修改Deployment部分：（同时可以修改一下 网站的信息：） eg: 12345678# Sitetitle: wangChen subtitle: 问世间，情为何物，直教生死相许？ description: wangChen的学习笔记keywords: 学习使我快乐 工作使我快乐 author: wangChen language: ch-ZN timezone: 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/handsome-owner/handsome-owner.github.io.git branch: master 此时：运行 hexo d 会出现下面的错误： 需要执行下面的命令 安装依赖：. npm install hexo-deployer-git -–save 然后继续 hexo d 会提示你输入github的用户名 密码。 …….. 到现在为止 就已经部署完了 可以在浏览器中 输入 github的地址 查看： eg: 在这里我的地址为： https://handsome-owner.github.io/ 修改更换hexo的主题：官网地址 个人喜欢的主题：yilia主题 git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia modernist git clone https://github.com/heroicyang/hexo-theme-modernist.git themes/modernist 修改主题：修改根目录下的配置文件： _config.yml theme: yilia 123hexo ghexo s# 就可以在浏览器中进行预览了 localhost:4000 配置文件介绍：根目录下配置文件介绍：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# Hexo Configuration## Docs: http://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site #整站的基本信息title: wangChen #网站标题subtitle: 问世间，情为何物，直教生死相许？ #网站副标题description: 学习使我快乐 工作使我快乐 #网站描述author: wangChen #网站作者，在下方显示email: xxxxx@qq.com #联系邮箱language: zh-CN #主题实际的文件名称timezone:# URL #这项暂不配置，绑定域名后，欲创建sitemap.xml需要配置该项## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://yoursite.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writing 文章布局、写作格式的定义，不修改new_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: true tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format 日期格式，不修改## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination 每页显示文章数，可以自定义## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Disqus Disqus插件，我们会替换成“多说”，不修改disqus_shortname:# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: yilia# 自动生成sitemapsitemap:path: sitemap.xmlbaidusitemap:path: baidusitemap.xml# Deployment 站点部署到github要配置 ## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/handsome-owner/handsome-owner.github.io.git branch: master 页面部分设置：页面展现的全部逻辑都在各个主题中控制，源代码在根目录下的 themes\主题名称\中： hexo\themes\ 1234567891011121314151617├── languages #多语言| ├── default.yml#默认语言| └── zh-CN.yml #中文语言├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制| ├── _partial #局部的布局，此目录下的*.ejs是对头尾等局部的控制| └── _widget#小挂件的布局，页面下方小挂件的控制├── source #源码| ├── css#css源码 | | ├── _base #*.styl基础css| | ├── _partial #*.styl局部css| | ├── fonts #字体| | ├── images #图片| | └── style.styl #*.styl引入需要的css源码| ├── fancybox #fancybox效果源码| └── js #javascript源代码├── _config.yml #主题配置文件└── README.md #用GitHub的都知道 主题下的配置文件： _config.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# Headermenu: 主页: / 所有文章: /archives # 随笔: /tags/随笔# SubNavsubnav: github: "#" weibo: "#" rss: "#" zhihu: "#" #douban: "#" #mail: "#" #facebook: "#" #google: "#" #twitter: "#" #linkedin: "#"rss: /atom.xml# Contentexcerpt_link: morefancybox: truemathjax: true# Miscellaneousgoogle_analytics: ''favicon: /favicon.png#你的头像urlavatar: /img/1.jpg #根目录下img文件夹下#是否开启分享share: true#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key（http://duoshuo-key.duoshuo.com/）#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论duoshuo: true#是否开启云标签tagcloud: true#是否开启友情链接#不开启——#friends: false#开启——friends: 奥巴马的博客: http://localhost:4000/ 卡卡的美丽传说: http://localhost:4000/ 本泽马的博客: http://localhost:4000/ 吉格斯的博客: http://localhost:4000/ 习大大大不同: http://localhost:4000/ 托蒂的博客: http://localhost:4000/#是否开启“关于我”。#不开启——#aboutme: false#开启——aboutme: 马哈马哈 叽咕叽咕 ..... 新建博客：hexo new &quot;使用hexo来搭建个人网站&quot; 可以看到在source目录中 生成了一个md文件。 然后编辑完毕之后 可以在本地先查看一下 12hexo generate 或 hexo g hexo server 或 hexo s 参考链接：https://blog.csdn.net/erchowyo/article/details/54407601]]></content>
      <tags>
        <tag>hexo 软件安装</tag>
      </tags>
  </entry>
</search>
