<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[微服务的构建-SpringBoot]]></title>
    <url>%2F2019%2F10%2F10%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%84%E5%BB%BA-SpringBoot%2F</url>
    <content type="text"><![CDATA[微服务构建 SpringBoot SpringCloud的出现，可以说是对微服务架构的巨大支持，和强有力的技术后盾。他是一个解决微服务架构实施的综合性解决框架，整合了诸多被广泛实践和证明过的框架作为实施的基础部件，又在该体系上创建了一些优秀的边缘组件。 SpringCloud 简介：Spring Cloud 是一个基于 SpringBoot的微服务架构开发工具。他为微服务架构中涉及到的配置管理、服务治理、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群管理状态等操作，提供了一种简单的开发方式。 SpringCloud包含多个子项目，针对分布式系统中涉及到的多个不同开源产品，有以下几个组件： Spring Cloud Netflix: 核心组件： Eureka： 服务治理组件，包含服务注册中心、服务注册和发现机制的实现。 Hystrix：容错管理组件，实现断路器模式，帮助服务依赖中出现的延迟和为故障提供强大的容错能力。 Ribbon：客户端负载均衡的服务调用组件 Feign：基于Ribbon和Hystrix的声明式服务调用组件 Zuul： 网关组件，提供智能路由、访问过滤等功能。 Archaius： 外部化配置组件 Spring Cloud Bus: 事件 消息总线，用于传播集群中的状态变化或事件，以触发后续的处理，比如：用来动态刷新配置等。 Spring Cloud Cluster：针对Zookeeper、Redis、Hazelcast、Consul的选举算法和通用状态模式的实现。 Spring Cloud Cloudfoundry：与Privotal Cloudfoundry的整合支持。 Spring Cloud Consul : 服务发现和配置管理工具 Spring Cloud Stream：通过Redis、Rabbit、或者kafka 实现的消费微服务，可以通过简单的声明式模型来发送和接收消息。 Spring Cloud Security：安全工具包，提供在Zuul中代理对OAuth2 客户端请求的中继器。 Spring Cloud Zookeeper：基于Zookeeper的服务发现和配置管理组件。 Spring Cloud Config：配置管理工具，支持使用Git来存储配置内容，可以使用它实现应用配置的外部化存储，并支持客户端配置信息刷新，加密/解密配置内容等。 ……. 微服务构建：SpringBoot：构建微服务的基础框架：SpringBoot SpringBoot 是SpringCloud的基础，同样，也是一个非常优秀的框架。支持 自动化配置、快速开发、轻松部署，非常适合作为微服务架构中各项具体微服务的开发框架。 框架简介：对于Spring 框架的初学者来说，经常会因为其繁杂的配置文件而却不。对于很多老手来说，每次新构建项目，总是需要重复复制粘贴一些差不多的配置文件这样枯燥乏味的事。或者，我们可以通过Maven等构件工具来创建针对不同场景的加脚手架工程，在需要新建项目时，通过这些脚手架来初始化我们自定义的标准工程，并根据简单修改以达到简化原有配置过程的效果。这样的手段，虽然减少了工作量，但是这些配置依然大量散布在我们的工程中，大部分情况下，我们并不会修改其中的内容，但为什么还要反复出现在我们的工程中呢？ SpringBoot的出现可以有效改善这类问题，SpringBoot的出现并不是要重写Spring或者代替Spring，而是希望通过大量的自动化配置的方式来简化Spring原有样板化的配置，使得开发者可以快速构建应用。 除了解决配置问题之外呢，SpringBoot还通过了一系列的Starter POMs的定义，让我们整合各项功能的时候，不需要在Maven的pom.xml中维护那些错综 复杂的依赖关系，而是通过类似模块化的Starter模块定义来引用，使得依赖管理变得更简单。 在当前容器化大行其道的时代，Spring Boot除了可以很好的融入Docker之外，其自身就支持嵌入式的Tomcat，Jetty等容器。所以，通过Spring Boot构建的应用不再需要安装Tomcat，将应用打成war包，再部署到Tomcat这样复杂的构建与部署工作。只需要将应用打成jar包，并通过java -jar的命令直接运行就能启动一个标准化的WEB应用，这使得SpringBoot应用变得更轻便。 SpringBoot对构建 ，部署做了这么多的优化，在开发环节也有许多的优化。整个SpringBoot的生态系统都使用到了Groovy，很自然地，我们可以使用Groovy Gradle来开发SpringBoot应用。 快速开始：下面我们创建一个简单的Spring Boot 基础项目，并且实现一个简单的RESTful API。 使用工具： jdk8、maven3.5+、idea开发 eg: pom.xml文件: 只需要引入 spring-boot-starter-web 全栈WEB开发，包含tomcat 以及 Spring MVC 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.9.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.wc.test&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-hello&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-hello&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 实现RESTful API : 12345678@RestControllerpublic class HelloController &#123; @GetMapping("/sayHello") public String sayHello()&#123; return "hello world"; &#125;&#125; 默认的端口是 8080 只需要在浏览器输入 localhost:8080/sayHello 就会看到返回的 hello world 。 配置详解：在上面的例子中，我们只是使用了很少的代码就实现了一个RESTful API。 在 src/main/resources 下面是SpringBoot项目的配置目录，在当前目录下进行应用的个性化配置。 在当前目录下存在一个application.properties文件，此文件是该应用的配置文件，我们一般使用yml文件，将其改名为application.yml ，可以在当前文件中定义文件的端口号，数据库连接信息，日志级别等各种配置信息。例如：我们可以通过 server.port=8888，来修改端口，spring.application.name=hello 来修改应用名。 YAML（/ˈjæməl/，尾音类似 camel 骆驼）是一个可读性高，用来表达数据序列化的格式。YAML 参考了其他多种语言，包括： C 语言、 Python、Perl，并从 XML、电子邮件的数据格式（RFC 2822）中获得灵感。Clark Evans 在 2001 年首次发表了这种语言 ，另外 Ingy döt Net 与 Oren Ben-Kiki 也是这语言的共同设计者 。当前已经有数种编程语言或脚本语言支持（或者说解析）这种语言。 YAML 是 “YAML Ain’t a Markup Language”（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时， YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言，但为了强调这种语言以数据做为中心，而不是以标记语言为重点，而用反向缩略语重命名。 eg: 12345server: port: 8888spring: application: name: hello 自定义参数：我们可以在配置文件 application.yml 中添加一些自定义的参数： 123book: name: SpringCloud实战 price: 25.5 在应用中可以通过@Value注解来加载这些自定义参数： 1234567891011121314@RestControllerpublic class HelloController &#123; @Value("$&#123;book.name&#125;") private String bookName; @Value("$&#123;book.price&#125;") private double bookPrice; @GetMapping("/getBook") public Book getBook()&#123; return new Book(bookName,bookPrice); &#125;&#125; @Value注解加载属性值的时候可以支持两种表达式来配置， 一种是上面的这种形式 plcaeHolder 格式为：${…} 大括号内为 placeHolder 另外一种就是SpEL表达式，格式为 #{…} 大括号内为SpEL表达式。 参数引用：在application.yml 中的各参数之间可以通过使用placeHolder的方式来引用，就像下面的配置一样： 1234book: name: SpringCloud实战 price: 25.5 description: $&#123;book.name&#125; 价格： $&#123;book.price&#125; 使用随机数：在一些情况下，我们希望有些参数在每次加载的时候不是一个固定的值，比如：秘钥 服务端口等。在Spring Boot的属性配置文件中，可以通过${random} 配置来产生随机的int值，long值，或者string字符串。这样我们可以很容易的通过配置随机生成属性，而不是在程序中通过编码来实现这些逻辑。 1234567891011#$&#123;random&#125;的配置方式主要有以下四种：#随机字符串：random.str: $&#123;random.value&#125;#随机intrandom.int: $&#123;random.int&#125;#随机longrandom.long: $&#123;random.long&#125;#10以内的随机数random.int2: $&#123;random.int(10)&#125;#10~20的随机数random.int3: $&#123;random.int(10,20)&#125; 可以设置应用端口等场景，以避免在本地调试的时候出现端口冲突的错误。 命令行参数：打成jar包的应用，可以通过java -jar的 方式启动，可以在命令行中指定应用的参数 eg: java -jar xxx.jar –server.port=8888，将启动后应用的端口设置为8888。 在用命令行的方式启动应用时，连续的两个减号 – 就是对application.properties 中属性值进行赋值的标识。等价于在配置文件中设置server.port=8888。 通过此特性，使得应用的属性在启动前是可变的。 多环境配置：我们在开发应用的时候，不同大的环境（开发、测试、生产）需要不同的配置值 （数据库地址、服务器端口等），如果不同的环境需要不断的修改配置文件再打包的话，将是非常繁琐且容易发生错误的事。 对于多环境的支持，各种构件工具或者框架的解决思路都是一致的，通过配置多份不同环境的配置文件，再通过打包命令指定需要打包的内容之后进行区分打包，SpringBoot也是这样的思路，其实现起来更加简单。 在SpringBoot中，多环境的配置文件需要满足application-{profile}.yml 这样的形式，其中{profile}是对应环境的标识。如下所示： application-dev.yml 开发环境 application-test.yml 测试环境 application-prod.yml 生产环境 至于需要指定使用哪个环境，需要在application.yml 中指定： 123spring: profiles: active: test 我们可以在application.yml中配置通用的内容，然后在不同的环境配置文件中配置需要变动的配置。 加载顺序：我们现在已经知道，我们将配内容都放在了项目的配置文件中，同时支持多环境配置。但是，在业务复杂之后，往往不需要让开发人员知道测试或是生产环境的细节，而是希望各个环境的负责人来集中维护这些信息，如果是以这样的方式存储配置内容，对于不同环境配置的修改就不得不去获取工程内容来修改这些配置内容，当应用非常多的时候，就会非常不方便，同时，配置内容对开发人员都可见，这本身就是一种安全隐患。 对此出现了很多配置内容外部化的框架和工具，Spring Cloud Config 就是其中之一。 为了能够更合理的重写各属性的值，SpringBoot使用下面的属性加载顺序。 在命令行中传入的参数 SPRING_APPLICATION_JSON 中的属性，SPRING_APPLICATION_JSON是以json格式配置在系统环境变量中的内容。 java:comp/env 中的jndi属性 java的系统属性，可以通过System.getProperties() 获得内容 操作系统的环境变量 通过random.* 配置的随机属性 位于当前jar包之外，针对不同的application-{profile}.yml 配置文件内容 位于当前jar包之内，针对不同环境的 application-{profile}.yml 位于当前jar包之外的，application.yml内容 位于当前jar包之内的，application.yml内容 在@Configuration注解修改的类中 通过@PropertySource注解定义的内容。 应用默认属性，使用SpringApplication.setDefaultProperties定义的内容。 有限按照上面的顺序由高到低，数字越小优先级越高。 监控与管理：在微服务的架构中，我们将原本一个复杂的应用拆分为多个提供不同服务的应用，虽然各个因应用的内部因分解而得以优化，但是由于部署的应用成倍的增加，使得系统的维护复杂度大大提升。这样系统集群中出现故障的评率也越来越高，虽然在高可用机制的作用下，单个应用的故障不会影响系统的对外服务，但是出现故障的应用需要被及时的处理才能让系统保持健康可用的状态。 我们需要一套自动化的监控运维机制，而这套机制的运行基础就是不断的收集各个微服务应用的各项指标情况，并根据这些指标信息来指定监控和预警规则，更进一步做到一些自动化的运维操作等。需要一套专门植入各个微服务应用的接口供检测系统采集信息，比如：环境变量、垃圾收集信息、内存信息、线程池信息等。 SpringBoot中存在一个这样的模块 spring-boot-starter-actuator。引入该模块可以为SpringBoot的应用提供一些列用于监控的端点。同时Spring Cloud 在实现各个微服务组件的时候 ，进一步为该模块做了不少 扩展，比如：为原生端点增加了更多的指标和度量信息（比如 在整合Eureka的时候 会为/health端点增加相关的信息），并且根据不同的组件还提供了更多用空的端点。（比如：为API网关组件 Zuul 提供了 /routes 端点来返回路由信息）。 初识actuator：首先需要在pom.xml中添加依赖 spring-boot-starter-actuator 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 增加了该模块之后，重新启动应用，可以看到下面的输出: 12019-10-11 10:19:35.858 INFO 15984 --- [ main] o.s.b.a.e.web.EndpointLinksResolver : Exposing 2 endpoint(s) beneath base path &apos;/actuator&apos; 在浏览器中访问： localhost:8888/actuator 可以看到下面的输出结果： 123456789101112131415161718192021222324&#123; "_links": &#123; "self": &#123; "href": "http://localhost:8888/actuator", "templated": false &#125;, "health": &#123; "href": "http://localhost:8888/actuator/health", "templated": false &#125;, "health-component": &#123; "href": "http://localhost:8888/actuator/health/&#123;component&#125;", "templated": true &#125;, "health-component-instance": &#123; "href": "http://localhost:8888/actuator/health/&#123;component&#125;/&#123;instance&#125;", "templated": true &#125;, "info": &#123; "href": "http://localhost:8888/actuator/info", "templated": false &#125; &#125;&#125; 我们可以看一下health 的结果： http://localhost:8888/actuator/health 123&#123; "status": "UP"&#125; 没有引入其他模块时，改端点的内容比较简单，后续我们在使用Spring Cloud 的时候，他的返回就会变得非常丰富。这些内容将帮助我们制定更加给个性化的监控策略。 参考资料：SpringCloud微服务实战 SpringCloud微服务架构实践]]></content>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是微服务]]></title>
    <url>%2F2019%2F10%2F09%2F%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[什么是微服务？微服务是一种架构风格，将单体应用划分为小型的服务单元，微服务之间使用HTTP的API进行资源的访问和操作。微服务架构的系统是一个分布式的系统，按业务进行划分为独立的服务单元，解决单体系统的不足，同时也满足越来越复杂的业务需求。单体架构：什么是单体架构：单体应用就是将应用程序的所有功能都打包成一个独立的单元。 在软件设计的时候经常提到和使用经典的3层模型，即表现层，业务逻辑层，数据访问层。虽然在软件设计中划分了3层模型，但是对业务场景没有划分，一个典型的单体架构就是将所有的业务场景的表现层，业务逻辑层，数据访问层放在一个工程中最终经过编译，打包，部署在一台服务器上。此时服务架构如图： 单体架构存在的优点：1.便于开发:只需借助IDE的开发、调试功能即可完成。 2.易于测试:只需要通过单元测试或浏览器即可完成测试。 3.易于部署:打包成单一可执行jar包，执行jar包即可完成部署。 单体架构存在的不足：应用程序随着业务需求的迭代，功能的追加扩展,最终成为一个庞然大物。变得更加复杂，逻辑耦合严重，难以理解，团队开发 人员职责不清，部署困难，回归测试成本巨大，交付效率大大降低，总结下来，单体应用有以下缺点: 1. 复杂性高 代码难以理解在业务规模和团队规模发展的一定阶段，这些不足表现的更加明显，单体架构的不足首先表现在复杂性上, maven模块增多，多个模块耦合在一起，代码结构混乱，使得团队成员没有一个人理解整个代码逻辑； 难以理解导致代码质量低，复杂性进一步增加难以理解导致代码复用度降低，因为你不知道哪些可以复用的；即便修改，影响范围也不好确定，这导致这样开发宁愿新建一个新方法和新的类，进一步导致重复代码越积越多； 代码难以被修改和重构不理解代码当然也就写不出高内聚低耦合的代码，和代码质量持续下降；复杂性进一步增加随着复杂度的增加，耦合度越来越高，代码牵一发而动全身，代码已经很难修改和重构了 团队职责不清晰高度耦合的单体工程使得逻辑边界模糊不清，新的业务需求开发任务无法有效分配到人，团队人员职责不清晰，沟通成本增加。 2.交付效率低 构建和部署耗时长，难以定位问题，开发效率低代码量比较庞大，首先是编译耗时变长，开发调试将大部分时间花在重新编译上，代码量的增加又很难定位bug，导致开发效率进一步降低，在代码合并过程中极易遇到代码冲突，又花上不少时间用在解决代码冲突上；这都是导致开发效率低下的因素； 代码复杂和变更影响难以理解，需要数天完成全量测试当我们开发完一个新的功能或者修复一个bug，代码的变更影响是很难预估的，所以每次发布之前都要进去全量功能的回归测试； 全量部署耗时长、影响范围广、风险大，发布频次低正因为这种全量部署耗时长、影响范围广、风险大，导致我们将很多功能和修复聚集在一起进行开发完成，这导致了产品发布频次降低，新的功和更换的体验能不能及时呈现给用户，甚至被竞争对手赶超。 3.伸缩性(scalable)差 单体只能按整体横向扩展，无法分模块垂直扩展 IO密集型模块和CPU密集型模块无法独立升级和扩容业务模块对资源的需求是不一样的，由于所有模块部署到一起，单体架构IO密集型模块和CPU密集型模块无法独立升级和扩容的，比如图片压缩，加解密这些 都是cpu资源密集的应该升级CPU，而IO密集型的模块比如日志收集服务IO操作比较多需要更大的内存，使用比如SSD性能更好的磁盘。 4. 可靠性差 一个bug有可能引起整个应用的崩溃由于所有模块都是部署在一个实例中，一个bug会引起整个应用的崩溃，比如一个不重要的模块的内存泄露就将会导致所有应用实例一个个crash掉 5.阻碍技术创新 受技术栈限制 团队成员使用同一框架和语言，模块得不到拆分，不能使用新的语言和框架。 升级和变革技术框架变得困难当有符合业务场景的新技术产生或者新版本时，升级和变革技术框架所带来的重构成本和风险变革很高。 尝试新语言变得困难想尝试新的语言也变得很困难，因为开发成本的上升，重构和新需求迭代无法协调，所以最终只能是妥协继续使用原来的框架和语言 那么如何解决单体的不足呢，通过迁移到微服务架构来解决，我们看一下什么是微服务。 微服务：什么是微服务架构：微服务架构:将单体应用拆分为多个高内聚低耦合的小型服务，每个小服务运行在独立进程，由不同的团队开发和维护，服务间采用轻量级通信机制，独立自动部署，可以采用不同的语言及存储。 我们通过上图来看下单体架构到微服务架构的对比。此图是一个简单电商单体到微服务架构的演进图，单体架构整个团队维护开发一个大工程及一个单库，到了微服务架构，用户请求经过API Gateway被路由到下游服务，服务之间以轻量级通信协议进行通信，服务通过注册中心发现彼此，每个服务都有专门的开发维护团队，每个服务对应独立的数据库，服务独立开发，独立部署和上线。 接下来我们总结下微服务的优点。 微服务的优点：1.易于开发与维护 微服务相对小，易于理解 启动时间短，开发效率高 2.独立部署 一个微服务的修改不需要协调其它服务 3.伸缩性强 每个服务都可以在横向和纵向上扩展 每个服务都可按硬件资源的需求进行独立扩容 4.与组织结构相匹配 微服务架构可以更好将架构和组织相匹配 每个团队独立负责某些服务，获得更高的生产力 5.技术异构性 使用最适合该服务的技术 降低尝试新技术的成本 微服务的挑战没有任何技术是银弹，微服务也是如此 ,都或多或少有一些缺点和问题。那么我们就必须针对这些问题一一解决，也是我们接下来章节重点去做的. 我首先面对就是要将单体拆分成多个服务。 1.服务拆分 微服务拆分原则:领域模型、限定上下文、组织架构、康威定律现实中没有一个具体明确的方法可以将拆分一步到位，而是遵守一定的原则，比如根据领域模型、组织架构、单一职责这些进行拆分在拆分的过程中还要结合经验判断，并且随着需求迭代，架构持续优化演进，优化服务的拆分。 每个微服务拥有独立数据库服务拆分的同时还要考虑到存储数据库也要独立，当多个服务直接读写数据库中同一张表时，对这些表做任何改动都需要协调这些相关服务的部署。这一点违背了服务相互独立这一原则。共享的数据存储很容易不经意间造成耦合。每个服务需要有自己的私有数据。比如订单表被订单服务和商品服务所共享，商品服务单独做统计并不知道自己一天多少商品被卖出，不知道哪些数据由本服务产生的，就无法进行技术产品规划，对表结构的修改也要通知多个服务，这是所不能容忍的。每个服务需要自己的数据库，但这些数据库可共置在一台共享的数据服务器上，数据库私有的重点在于不应让服务知道其他服务底层数据库的存在。可用一台共享数据服务器先开始开发，以后如果数据量和并发量变大，服务器可以进行隔离。服务器隔离后，只要更改配置即可将不同服务的数据库隔离起来。 微服务之间确定服务边界,通过共享模型建立联系每个微服务都具备自己的业务能力，那么服务之间交互的部分即是服务边界； 确定服务边界也是一个难题，需要对自己的产品和业务有足够的了解才能确定最自然的服务边界。确定服务边界坚持的原则是要高内聚弱耦合，弱耦合就是一个服务与其他服务的任何通信都应通过公开暴露的接口（API、事件等）实现，这些接口需要妥善设计以隐藏内部细节。这样我们的服务之间保持独立，在未来我们可以轻松重构，高内聚力就是密切相关的多个功能应尽量包含在同一个服务中，这样可将服务之间的干扰降至最低。 2.数据一致性 在单体架构中，我们通过数据库事务完成的操作 放在分布式微服务架构下无法完成了，因为实例被部署不同服务器上,比如订单服务进行下单操作，下单操作和扣减库存应该放在同一个事务中，在微服务架构下，下单操作和扣库存操作被分布在不同服务器上，就需要进行分布式事务操作,而分布式事务具有延迟较高、nosql数据库不支持等缺点。这些缺点导致分布式事务无法应用到微服务中在微服务场景下，我们通常使用最终一致性来代替强一致性。 可靠性事件模式 补偿模式-sagas模式 3.服务通信 通信技术方案: RPC vs REST vs 异步消息 RPC、REST API、异步消息，异步消息我们可以借助一些消息队列框架来实现比如kafka、rabbitMQ，那现在我们说下rpc和使用http协议的类似REST API之间 如何选择，TTP的好处是方便调试、跨语言、门槛低、广泛接受，同样缺点是协议文档不好维护，协议较为繁琐，性能较TCP要差是http协议的不足。Rpc通信通常基于Tcp，常用的技术选型是thrift、grpc、dubbo，像thrift、grpc需要定义idl文件，通过idl文件来生成java代码，通过rpc的好处是IDE友好，有代码提示，协议维护在代码中，传参和响应结果都通过代码可以知道。但同时也有缺点比如很多rpc方案不知道跨语言，所支持的语言有限，需要定义和维护idl文件，且有一定的学习成本，另外rpc不容易方便的调试和测试 服务注册和发现 在服务实例变化不定的环境中，用硬编码指定IP地址的方式是行不通的，需要通过某种发现机制让服务能相互查找。这就需要我们将我们的服务信息注册到一个分布式存储中，这些服务信息就叫做服务注册表服务注册表可以作为信息的权威来源。其中包含有关可用服务的信息，以及服务网络位置比如ip、端口号这些信息。那借助什么组件进行实现呢，一般有Eureka和zookeeper，除此之外我们还可以借助etcd，consul，redis这些。 负载均衡 有了注册发现功能，客户端通过服务注册表发现实例清单并决定要连接哪个实例，在客户端做负载均衡，基于客户端做负载均衡相比服务端负载均衡有诸多好处：首先节省了硬件均衡设备，减少了运维成本，其次可以实现多种负载均衡策略比如响应感知的负载均衡策略。 4.服务网关 API Gateway我们的微服务如果和终端用户交互，势必要考虑身份认证、安全防御等这些方面，如果每个微服务都与终端用户打交道，那么这些方面代码需要拷贝多份植入到每个微服务业务代码中。这造成了业务代码和身份认证代码的耦合，降低了代码的复用性。这就需要在网络边界实现一个服务网关（这里的网络边界可以认为是内网和外网之间的边界），将身份认证，安全防御，流量控制这些功能放到服务网关中，向业务服务屏蔽网络边界服务的细节，使得业务服务专注于业务逻辑的开发维护和测试。 为前端服务的后端(Backends For Forntends)服务网关可以根据终端产品形态来划分，比如公共API,桌面客户端，移动客户端分别对应一个服务网关，而服务网关可以是API Gateway只输出api，或者是为前端服务的后端，这里的为前端服务的后端，比如将来自多个服务的数据聚合到一起返回给前端。 身份认证、路由服务、限流防刷、日志统计 5.高可观察 健康检测、集中监控 每个服务和使用的组件都有提供健康检测机制，使得我们可以及时发现异常的节点，然后做出判断和调整，将所有的监控指标进行聚合输出可视化图表和界面帮助我们快速直观发现问题。 日志聚合及检索 比如在电商app我们发现无法进行下单操作，在分布式架构下，日志散落在多个服务多个服务器中，我们不知道错误日志打在哪台服务器上，如果每台服务器去登陆去看是极其低效的。这要求我们做到日志格式标准化，并通过一些手段聚合到一起进行检索查询。同时可跨越所有服务、特定的某个服务，或服务的某个实例搜索日志；将日志发送至集中化日志系统所用的代码可包含在共享库中或通过代码脚手架提供。 分布式追踪 在微服务架构场景中，一个客户端发起的请求要经过多个服务的调用最终聚合数据结构返回给客户端，但我们不知道这个请求不知道经过哪些服务，调用哪个服务出现了问题，每个服务的输入输出是什么，这给我们定位问题带来了困扰，除此以外，如果一个请求耗时较长，我们不知道到底哪个服务耗时最长，好有针对性的性能优化。随着架构的演进，我们在架构设计规划时需要知道 服务之间的依赖关系，这有需要什么技术来实现呢，这就是我们要介绍的分布式追踪，分布式追踪借助关联id，在请求源头创建这个关联id，并且在服务间进行透传，最终将关联id等信息聚合到一起进行查询分析。 6.可靠性在讲单体的过程中，我们讲到，一个业务模块的内存泄露会导致整个进程退出。 在微服务场景下，如果一个服务出现内存泄露是不会影响 没有依赖关系的服务的。 但是却可以因为该异常服务的僵死或不可用造成上游服务线程hang住，进而产生级联效应，故障进一步向上游传播。 流量控制，超时控制 可靠性技术通过流量的控制和超时控制，保证服务消费者不被下游服务拖慢，及时对业务线程循环复用。 舱壁隔离，熔断机制 熔断是指服务调用出错次数在一定时间达到一定数量，自动关闭对该服务的调用开关，改为返回错误或者将请求转交给降级方法，降低资源耗尽的风险，当服务不可用时，作为服务消费者应该对接口方法编写一个降级方法。 服务降级, 幂等重试 由于服务间通信是通过网络传输的，网络异常和网络分区故障 就会经常出现，我们遇到这种情况可以进行调用重试，重试时要注意两点，一个是接口必须是幂等的，无论运行一次或多次，最终结果必须相同。幂等性保证了重试不会产生负面影响。在重试过程时休眠时间应该是指数增长的，否则会产生惊群效应，比如：故障后的服务恢复上线后，如果有大量其他服务正在同一个重试窗口内重试，此时很容易给系统造成巨大压力。 参考链接： 学习微服务首先了解为什么使用微服务 什么是微服务]]></content>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo来搭建个人网站]]></title>
    <url>%2F2019%2F09%2F30%2F%E4%BD%BF%E7%94%A8hexo%E6%9D%A5%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[hexo是什么？ Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 使用hexo的前置准备： 需要在本机有 git node的环境 Node.js 下载地址 直接下载安装版本 会自动配置环境变量 同时安装npm git 下载地址 配置环境变量 Typora 一款好用的md编辑器 需要有一个github的账号 同时新建一个仓库 创建一个repo，名称为yourname.github.io, 其中yourname是你的github名称，按照这个规则创建才有用。 新建一个文件夹 hexo来保存hexo的文件 同时也是以后md文件的存放地址 开始安装hexo：进入到上面新建的目录中，然后右键 git bash here 首先替换npm的国内镜像源： npm config set registry=&quot;http://registry.cnpmjs.org&quot; 开始安装了： npm install -g hexo 会在文件夹中出现新的文件 hexo init 安装依赖包，hexo 会自动在自动在文件夹中建立网站所需的文件。 npm install 生成静态页面到public目录（静态博客就在这个位置） hexo generate 开启预览访问端口，默认端口4000 可在浏览器中查看 hexo server 在浏览器中访问： localhost:4000 ,可以进行预览。每次变更_config.yml 文件或者上传文件都可以现在本次查看一下 部署到github:hexo d 在此之前需要先修改根目录下的 _config.yml 修改Deployment部分：（同时可以修改一下 网站的信息：） eg: 12345678# Sitetitle: wangChen subtitle: 问世间，情为何物，直教生死相许？ description: wangChen的学习笔记keywords: 学习使我快乐 工作使我快乐 author: wangChen language: ch-ZN timezone: 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/handsome-owner/handsome-owner.github.io.git branch: master 此时：运行 hexo d 会出现下面的错误： 需要执行下面的命令 安装依赖：. npm install hexo-deployer-git -–save 然后继续 hexo d 会提示你输入github的用户名 密码。 …….. 到现在为止 就已经部署完了 可以在浏览器中 输入 github的地址 查看： eg: 在这里我的地址为： https://handsome-owner.github.io/ 修改更换hexo的主题：官网地址 个人喜欢的主题：yilia主题 git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia modernist git clone https://github.com/heroicyang/hexo-theme-modernist.git themes/modernist 修改主题：修改根目录下的配置文件： _config.yml theme: yilia 123hexo ghexo s# 就可以在浏览器中进行预览了 localhost:4000 配置文件介绍：根目录下配置文件介绍：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# Hexo Configuration## Docs: http://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site #整站的基本信息title: wangChen #网站标题subtitle: 问世间，情为何物，直教生死相许？ #网站副标题description: 学习使我快乐 工作使我快乐 #网站描述author: wangChen #网站作者，在下方显示email: xxxxx@qq.com #联系邮箱language: zh-CN #主题实际的文件名称timezone:# URL #这项暂不配置，绑定域名后，欲创建sitemap.xml需要配置该项## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://yoursite.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writing 文章布局、写作格式的定义，不修改new_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: true tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format 日期格式，不修改## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination 每页显示文章数，可以自定义## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Disqus Disqus插件，我们会替换成“多说”，不修改disqus_shortname:# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: yilia# 自动生成sitemapsitemap:path: sitemap.xmlbaidusitemap:path: baidusitemap.xml# Deployment 站点部署到github要配置 ## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/handsome-owner/handsome-owner.github.io.git branch: master 页面部分设置：页面展现的全部逻辑都在各个主题中控制，源代码在根目录下的 themes\主题名称\中： hexo\themes\ 1234567891011121314151617├── languages #多语言| ├── default.yml#默认语言| └── zh-CN.yml #中文语言├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制| ├── _partial #局部的布局，此目录下的*.ejs是对头尾等局部的控制| └── _widget#小挂件的布局，页面下方小挂件的控制├── source #源码| ├── css#css源码 | | ├── _base #*.styl基础css| | ├── _partial #*.styl局部css| | ├── fonts #字体| | ├── images #图片| | └── style.styl #*.styl引入需要的css源码| ├── fancybox #fancybox效果源码| └── js #javascript源代码├── _config.yml #主题配置文件└── README.md #用GitHub的都知道 主题下的配置文件： _config.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# Headermenu: 主页: / 所有文章: /archives # 随笔: /tags/随笔# SubNavsubnav: github: "#" weibo: "#" rss: "#" zhihu: "#" #douban: "#" #mail: "#" #facebook: "#" #google: "#" #twitter: "#" #linkedin: "#"rss: /atom.xml# Contentexcerpt_link: morefancybox: truemathjax: true# Miscellaneousgoogle_analytics: ''favicon: /favicon.png#你的头像urlavatar: /img/1.jpg #根目录下img文件夹下#是否开启分享share: true#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key（http://duoshuo-key.duoshuo.com/）#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论duoshuo: true#是否开启云标签tagcloud: true#是否开启友情链接#不开启——#friends: false#开启——friends: 奥巴马的博客: http://localhost:4000/ 卡卡的美丽传说: http://localhost:4000/ 本泽马的博客: http://localhost:4000/ 吉格斯的博客: http://localhost:4000/ 习大大大不同: http://localhost:4000/ 托蒂的博客: http://localhost:4000/#是否开启“关于我”。#不开启——#aboutme: false#开启——aboutme: 马哈马哈 叽咕叽咕 ..... 新建博客：hexo new &quot;使用hexo来搭建个人网站&quot; 可以看到在source目录中 生成了一个md文件。 然后编辑完毕之后 可以在本地先查看一下 12hexo generate 或 hexo g hexo server 或 hexo s 参考链接：https://blog.csdn.net/erchowyo/article/details/54407601]]></content>
      <tags>
        <tag>hexo 软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
