<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[什么是微服务]]></title>
    <url>%2F2019%2F10%2F09%2F%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[什么是微服务？​ 微服务是一种架构风格，将单体应用划分为小型的服务单元，微服务之间使用HTTP的API进行资源的访问和操作。​ 微服务架构的系统是一个分布式的系统，按业务进行划分为独立的服务单元，解决单体系统的不足，同时也满足越来越复杂的业务需求。单体架构：什么是单体架构： ​ 单体应用就是将应用程序的所有功能都打包成一个独立的单元。 ​ 在软件设计的时候经常提到和使用经典的3层模型，即表现层，业务逻辑层，数据访问层。虽然在软件设计中划分了3层模型，但是对业务场景没有划分，一个典型的单体架构就是将所有的业务场景的表现层，业务逻辑层，数据访问层放在一个工程中最终经过编译，打包，部署在一台服务器上。此时服务架构如图： 单体架构存在的优点：1.便于开发:只需借助IDE的开发、调试功能即可完成。 2.易于测试:只需要通过单元测试或浏览器即可完成测试。 3.易于部署:打包成单一可执行jar包，执行jar包即可完成部署。 单体架构存在的不足：​ 应用程序随着业务需求的迭代，功能的追加扩展,最终成为一个庞然大物。变得更加复杂，逻辑耦合严重，难以理解，团队开发 人员职责不清，部署困难，回归测试成本巨大，交付效率大大降低，总结下来，单体应用有以下缺点: 1. 复杂性高 代码难以理解在业务规模和团队规模发展的一定阶段，这些不足表现的更加明显，单体架构的不足首先表现在复杂性上, maven模块增多，多个模块耦合在一起，代码结构混乱，使得团队成员没有一个人理解整个代码逻辑； 难以理解导致代码质量低，复杂性进一步增加难以理解导致代码复用度降低，因为你不知道哪些可以复用的；即便修改，影响范围也不好确定，这导致这样开发宁愿新建一个新方法和新的类，进一步导致重复代码越积越多； 代码难以被修改和重构不理解代码当然也就写不出高内聚低耦合的代码，和代码质量持续下降；复杂性进一步增加随着复杂度的增加，耦合度越来越高，代码牵一发而动全身，代码已经很难修改和重构了 团队职责不清晰高度耦合的单体工程使得逻辑边界模糊不清，新的业务需求开发任务无法有效分配到人，团队人员职责不清晰，沟通成本增加。 2.交付效率低 构建和部署耗时长，难以定位问题，开发效率低代码量比较庞大，首先是编译耗时变长，开发调试将大部分时间花在重新编译上，代码量的增加又很难定位bug，导致开发效率进一步降低，在代码合并过程中极易遇到代码冲突，又花上不少时间用在解决代码冲突上；这都是导致开发效率低下的因素； 代码复杂和变更影响难以理解，需要数天完成全量测试当我们开发完一个新的功能或者修复一个bug，代码的变更影响是很难预估的，所以每次发布之前都要进去全量功能的回归测试； 全量部署耗时长、影响范围广、风险大，发布频次低正因为这种全量部署耗时长、影响范围广、风险大，导致我们将很多功能和修复聚集在一起进行开发完成，这导致了产品发布频次降低，新的功和更换的体验能不能及时呈现给用户，甚至被竞争对手赶超。 3.伸缩性(scalable)差 单体只能按整体横向扩展，无法分模块垂直扩展 IO密集型模块和CPU密集型模块无法独立升级和扩容业务模块对资源的需求是不一样的，由于所有模块部署到一起，单体架构IO密集型模块和CPU密集型模块无法独立升级和扩容的，比如图片压缩，加解密这些 都是cpu资源密集的应该升级CPU，而IO密集型的模块比如日志收集服务IO操作比较多需要更大的内存，使用比如SSD性能更好的磁盘。 4. 可靠性差 一个bug有可能引起整个应用的崩溃由于所有模块都是部署在一个实例中，一个bug会引起整个应用的崩溃，比如一个不重要的模块的内存泄露就将会导致所有应用实例一个个crash掉 5.阻碍技术创新 受技术栈限制 团队成员使用同一框架和语言，模块得不到拆分，不能使用新的语言和框架。 升级和变革技术框架变得困难当有符合业务场景的新技术产生或者新版本时，升级和变革技术框架所带来的重构成本和风险变革很高。 尝试新语言变得困难想尝试新的语言也变得很困难，因为开发成本的上升，重构和新需求迭代无法协调，所以最终只能是妥协继续使用原来的框架和语言 那么如何解决单体的不足呢，通过迁移到微服务架构来解决，我们看一下什么是微服务。 微服务：什么是微服务架构：​ 微服务架构:将单体应用拆分为多个高内聚低耦合的小型服务，每个小服务运行在独立进程，由不同的团队开发和维护，服务间采用轻量级通信机制，独立自动部署，可以采用不同的语言及存储。 ​ 我们通过上图来看下单体架构到微服务架构的对比。此图是一个简单电商单体到微服务架构的演进图，单体架构整个团队维护开发一个大工程及一个单库，到了微服务架构，用户请求经过API Gateway被路由到下游服务，服务之间以轻量级通信协议进行通信，服务通过注册中心发现彼此，每个服务都有专门的开发维护团队，每个服务对应独立的数据库，服务独立开发，独立部署和上线。 接下来我们总结下微服务的优点。 微服务的优点：1.易于开发与维护 微服务相对小，易于理解 启动时间短，开发效率高 2.独立部署 一个微服务的修改不需要协调其它服务 3.伸缩性强 每个服务都可以在横向和纵向上扩展 每个服务都可按硬件资源的需求进行独立扩容 4.与组织结构相匹配 微服务架构可以更好将架构和组织相匹配 每个团队独立负责某些服务，获得更高的生产力 5.技术异构性 使用最适合该服务的技术 降低尝试新技术的成本 微服务的挑战​ 没有任何技术是银弹，微服务也是如此 ,都或多或少有一些缺点和问题。那么我们就必须针对这些问题一一解决，也是我们接下来章节重点去做的. 我首先面对就是要将单体拆分成多个服务。 1.服务拆分 微服务拆分原则:领域模型、限定上下文、组织架构、康威定律现实中没有一个具体明确的方法可以将拆分一步到位，而是遵守一定的原则，比如根据领域模型、组织架构、单一职责这些进行拆分在拆分的过程中还要结合经验判断，并且随着需求迭代，架构持续优化演进，优化服务的拆分。 每个微服务拥有独立数据库服务拆分的同时还要考虑到存储数据库也要独立，当多个服务直接读写数据库中同一张表时，对这些表做任何改动都需要协调这些相关服务的部署。这一点违背了服务相互独立这一原则。共享的数据存储很容易不经意间造成耦合。每个服务需要有自己的私有数据。比如订单表被订单服务和商品服务所共享，商品服务单独做统计并不知道自己一天多少商品被卖出，不知道哪些数据由本服务产生的，就无法进行技术产品规划，对表结构的修改也要通知多个服务，这是所不能容忍的。每个服务需要自己的数据库，但这些数据库可共置在一台共享的数据服务器上，数据库私有的重点在于不应让服务知道其他服务底层数据库的存在。可用一台共享数据服务器先开始开发，以后如果数据量和并发量变大，服务器可以进行隔离。服务器隔离后，只要更改配置即可将不同服务的数据库隔离起来。 微服务之间确定服务边界,通过共享模型建立联系每个微服务都具备自己的业务能力，那么服务之间交互的部分即是服务边界； 确定服务边界也是一个难题，需要对自己的产品和业务有足够的了解才能确定最自然的服务边界。确定服务边界坚持的原则是要高内聚弱耦合，弱耦合就是一个服务与其他服务的任何通信都应通过公开暴露的接口（API、事件等）实现，这些接口需要妥善设计以隐藏内部细节。这样我们的服务之间保持独立，在未来我们可以轻松重构，高内聚力就是密切相关的多个功能应尽量包含在同一个服务中，这样可将服务之间的干扰降至最低。 2.数据一致性 在单体架构中，我们通过数据库事务完成的操作 放在分布式微服务架构下无法完成了，因为实例被部署不同服务器上,比如订单服务进行下单操作，下单操作和扣减库存应该放在同一个事务中，在微服务架构下，下单操作和扣库存操作被分布在不同服务器上，就需要进行分布式事务操作,而分布式事务具有延迟较高、nosql数据库不支持等缺点。这些缺点导致分布式事务无法应用到微服务中在微服务场景下，我们通常使用最终一致性来代替强一致性。 可靠性事件模式 补偿模式-sagas模式 3.服务通信 通信技术方案: RPC vs REST vs 异步消息 RPC、REST API、异步消息，异步消息我们可以借助一些消息队列框架来实现比如kafka、rabbitMQ，那现在我们说下rpc和使用http协议的类似REST API之间 如何选择，TTP的好处是方便调试、跨语言、门槛低、广泛接受，同样缺点是协议文档不好维护，协议较为繁琐，性能较TCP要差是http协议的不足。Rpc通信通常基于Tcp，常用的技术选型是thrift、grpc、dubbo，像thrift、grpc需要定义idl文件，通过idl文件来生成java代码，通过rpc的好处是IDE友好，有代码提示，协议维护在代码中，传参和响应结果都通过代码可以知道。但同时也有缺点比如很多rpc方案不知道跨语言，所支持的语言有限，需要定义和维护idl文件，且有一定的学习成本，另外rpc不容易方便的调试和测试 服务注册和发现 在服务实例变化不定的环境中，用硬编码指定IP地址的方式是行不通的，需要通过某种发现机制让服务能相互查找。这就需要我们将我们的服务信息注册到一个分布式存储中，这些服务信息就叫做服务注册表服务注册表可以作为信息的权威来源。其中包含有关可用服务的信息，以及服务网络位置比如ip、端口号这些信息。那借助什么组件进行实现呢，一般有Eureka和zookeeper，除此之外我们还可以借助etcd，consul，redis这些。 负载均衡 有了注册发现功能，客户端通过服务注册表发现实例清单并决定要连接哪个实例，在客户端做负载均衡，基于客户端做负载均衡相比服务端负载均衡有诸多好处：首先节省了硬件均衡设备，减少了运维成本，其次可以实现多种负载均衡策略比如响应感知的负载均衡策略。 4.服务网关 API Gateway我们的微服务如果和终端用户交互，势必要考虑身份认证、安全防御等这些方面，如果每个微服务都与终端用户打交道，那么这些方面代码需要拷贝多份植入到每个微服务业务代码中。这造成了业务代码和身份认证代码的耦合，降低了代码的复用性。这就需要在网络边界实现一个服务网关（这里的网络边界可以认为是内网和外网之间的边界），将身份认证，安全防御，流量控制这些功能放到服务网关中，向业务服务屏蔽网络边界服务的细节，使得业务服务专注于业务逻辑的开发维护和测试。 为前端服务的后端(Backends For Forntends)服务网关可以根据终端产品形态来划分，比如公共API,桌面客户端，移动客户端分别对应一个服务网关，而服务网关可以是API Gateway只输出api，或者是为前端服务的后端，这里的为前端服务的后端，比如将来自多个服务的数据聚合到一起返回给前端。 身份认证、路由服务、限流防刷、日志统计 5.高可观察 健康检测、集中监控 每个服务和使用的组件都有提供健康检测机制，使得我们可以及时发现异常的节点，然后做出判断和调整，将所有的监控指标进行聚合输出可视化图表和界面帮助我们快速直观发现问题。 日志聚合及检索 比如在电商app我们发现无法进行下单操作，在分布式架构下，日志散落在多个服务多个服务器中，我们不知道错误日志打在哪台服务器上，如果每台服务器去登陆去看是极其低效的。这要求我们做到日志格式标准化，并通过一些手段聚合到一起进行检索查询。同时可跨越所有服务、特定的某个服务，或服务的某个实例搜索日志；将日志发送至集中化日志系统所用的代码可包含在共享库中或通过代码脚手架提供。 分布式追踪 在微服务架构场景中，一个客户端发起的请求要经过多个服务的调用最终聚合数据结构返回给客户端，但我们不知道这个请求不知道经过哪些服务，调用哪个服务出现了问题，每个服务的输入输出是什么，这给我们定位问题带来了困扰，除此以外，如果一个请求耗时较长，我们不知道到底哪个服务耗时最长，好有针对性的性能优化。随着架构的演进，我们在架构设计规划时需要知道 服务之间的依赖关系，这有需要什么技术来实现呢，这就是我们要介绍的分布式追踪，分布式追踪借助关联id，在请求源头创建这个关联id，并且在服务间进行透传，最终将关联id等信息聚合到一起进行查询分析。 6.可靠性在讲单体的过程中，我们讲到，一个业务模块的内存泄露会导致整个进程退出。 在微服务场景下，如果一个服务出现内存泄露是不会影响 没有依赖关系的服务的。 但是却可以因为该异常服务的僵死或不可用造成上游服务线程hang住，进而产生级联效应，故障进一步向上游传播。 流量控制，超时控制 可靠性技术通过流量的控制和超时控制，保证服务消费者不被下游服务拖慢，及时对业务线程循环复用。 舱壁隔离，熔断机制 熔断是指服务调用出错次数在一定时间达到一定数量，自动关闭对该服务的调用开关，改为返回错误或者将请求转交给降级方法，降低资源耗尽的风险，当服务不可用时，作为服务消费者应该对接口方法编写一个降级方法。 服务降级, 幂等重试 由于服务间通信是通过网络传输的，网络异常和网络分区故障 就会经常出现，我们遇到这种情况可以进行调用重试，重试时要注意两点，一个是接口必须是幂等的，无论运行一次或多次，最终结果必须相同。幂等性保证了重试不会产生负面影响。在重试过程时休眠时间应该是指数增长的，否则会产生惊群效应，比如：故障后的服务恢复上线后，如果有大量其他服务正在同一个重试窗口内重试，此时很容易给系统造成巨大压力。 参考链接： 学习微服务首先了解为什么使用微服务 什么是微服务]]></content>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo来搭建个人网站]]></title>
    <url>%2F2019%2F09%2F30%2F%E4%BD%BF%E7%94%A8hexo%E6%9D%A5%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[hexo是什么？ Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 使用hexo的前置准备： 需要在本机有 git node的环境 Node.js 下载地址 直接下载安装版本 会自动配置环境变量 同时安装npm git 下载地址 配置环境变量 Typora 一款好用的md编辑器 需要有一个github的账号 同时新建一个仓库 创建一个repo，名称为yourname.github.io, 其中yourname是你的github名称，按照这个规则创建才有用。 新建一个文件夹 hexo来保存hexo的文件 同时也是以后md文件的存放地址 开始安装hexo：进入到上面新建的目录中，然后右键 git bash here 首先替换npm的国内镜像源： npm config set registry=&quot;http://registry.cnpmjs.org&quot; 开始安装了： npm install -g hexo 会在文件夹中出现新的文件 hexo init 安装依赖包，hexo 会自动在自动在文件夹中建立网站所需的文件。 npm install 生成静态页面到public目录（静态博客就在这个位置） hexo generate 开启预览访问端口，默认端口4000 可在浏览器中查看 hexo server 在浏览器中访问： localhost:4000 ,可以进行预览。每次变更_config.yml 文件或者上传文件都可以现在本次查看一下 部署到github:hexo d 在此之前需要先修改根目录下的 _config.yml 修改Deployment部分：（同时可以修改一下 网站的信息：） eg: 12345678# Sitetitle: wangChen subtitle: 问世间，情为何物，直教生死相许？ description: wangChen的学习笔记keywords: 学习使我快乐 工作使我快乐 author: wangChen language: ch-ZN timezone: 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/handsome-owner/handsome-owner.github.io.git branch: master 此时：运行 hexo d 会出现下面的错误： 需要执行下面的命令 安装依赖：. npm install hexo-deployer-git -–save 然后继续 hexo d 会提示你输入github的用户名 密码。 …….. 到现在为止 就已经部署完了 可以在浏览器中 输入 github的地址 查看： eg: 在这里我的地址为： https://handsome-owner.github.io/ 修改更换hexo的主题：官网地址 个人喜欢的主题：yilia主题 git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia modernist git clone https://github.com/heroicyang/hexo-theme-modernist.git themes/modernist 修改主题：修改根目录下的配置文件： _config.yml theme: yilia 123hexo ghexo s# 就可以在浏览器中进行预览了 localhost:4000 配置文件介绍：根目录下配置文件介绍：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# Hexo Configuration## Docs: http://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site #整站的基本信息title: wangChen #网站标题subtitle: 问世间，情为何物，直教生死相许？ #网站副标题description: 学习使我快乐 工作使我快乐 #网站描述author: wangChen #网站作者，在下方显示email: xxxxx@qq.com #联系邮箱language: zh-CN #主题实际的文件名称timezone:# URL #这项暂不配置，绑定域名后，欲创建sitemap.xml需要配置该项## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://yoursite.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writing 文章布局、写作格式的定义，不修改new_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: true tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format 日期格式，不修改## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination 每页显示文章数，可以自定义## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Disqus Disqus插件，我们会替换成“多说”，不修改disqus_shortname:# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: yilia# 自动生成sitemapsitemap:path: sitemap.xmlbaidusitemap:path: baidusitemap.xml# Deployment 站点部署到github要配置 ## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/handsome-owner/handsome-owner.github.io.git branch: master 页面部分设置：页面展现的全部逻辑都在各个主题中控制，源代码在根目录下的 themes\主题名称\中： hexo\themes\ 1234567891011121314151617├── languages #多语言| ├── default.yml#默认语言| └── zh-CN.yml #中文语言├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制| ├── _partial #局部的布局，此目录下的*.ejs是对头尾等局部的控制| └── _widget#小挂件的布局，页面下方小挂件的控制├── source #源码| ├── css#css源码 | | ├── _base #*.styl基础css| | ├── _partial #*.styl局部css| | ├── fonts #字体| | ├── images #图片| | └── style.styl #*.styl引入需要的css源码| ├── fancybox #fancybox效果源码| └── js #javascript源代码├── _config.yml #主题配置文件└── README.md #用GitHub的都知道 主题下的配置文件： _config.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# Headermenu: 主页: / 所有文章: /archives # 随笔: /tags/随笔# SubNavsubnav: github: "#" weibo: "#" rss: "#" zhihu: "#" #douban: "#" #mail: "#" #facebook: "#" #google: "#" #twitter: "#" #linkedin: "#"rss: /atom.xml# Contentexcerpt_link: morefancybox: truemathjax: true# Miscellaneousgoogle_analytics: ''favicon: /favicon.png#你的头像urlavatar: /img/1.jpg #根目录下img文件夹下#是否开启分享share: true#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key（http://duoshuo-key.duoshuo.com/）#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论duoshuo: true#是否开启云标签tagcloud: true#是否开启友情链接#不开启——#friends: false#开启——friends: 奥巴马的博客: http://localhost:4000/ 卡卡的美丽传说: http://localhost:4000/ 本泽马的博客: http://localhost:4000/ 吉格斯的博客: http://localhost:4000/ 习大大大不同: http://localhost:4000/ 托蒂的博客: http://localhost:4000/#是否开启“关于我”。#不开启——#aboutme: false#开启——aboutme: 马哈马哈 叽咕叽咕 ..... 新建博客：hexo new &quot;使用hexo来搭建个人网站&quot; 可以看到在source目录中 生成了一个md文件。 然后编辑完毕之后 可以在本地先查看一下 12hexo generate 或 hexo g hexo server 或 hexo s 参考链接：https://blog.csdn.net/erchowyo/article/details/54407601]]></content>
      <tags>
        <tag>hexo 软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
